============================= test session starts ==============================
platform darwin -- Python 3.10.6, pytest-7.3.1, pluggy-1.0.0
rootdir: /Users/sahammond/rubricapp/BackEndFlask
plugins: anyio-3.6.1, cov-3.0.0
collected 33 items

Functions/test_files/test_genericImport.py FFFFFFFFFF                    [ 30%]
Functions/test_files/test_randAssignTeams.py FFFFF                       [ 45%]
Functions/test_files/test_teamBulkUpload.py .FFFFFFFF                    [ 72%]
Functions/test_files/test_teamImport.py FFFFFFFFF                        [100%]

=================================== FAILURES ===================================
_____________________ test_should_fail_with_file_not_found _____________________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/NonExistentFile.csv'
owner_id = 57, course_id = 16

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/NonExistentFile.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_file_not_found(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
>               generic_csv_to_db(
                    retrieve_file_path("NonExistentFile.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/NonExistentFile.csv'
owner_id = 57, course_id = 16

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/NonExistentFile.csv'
owner_id = 57, course_id = 16

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x10f0e3250>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f1041c0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 57}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f104220>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 57}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f1041c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f104220>
query = 'DELETE FROM `User` WHERE `User`.user_id = 57', args = {'user_id_1': 57}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f104220>
q = 'DELETE FROM `User` WHERE `User`.user_id = 57'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f04af80>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 57', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f04af80>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f0e2da0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f04af80>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f0e2830>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_file_not_found(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
                generic_csv_to_db(
                    retrieve_file_path("NonExistentFile.csv"),
                    result["user_id"],
                    result["course_id"]
                )
            except Exception as e:
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 57}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:40,517 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 57}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 57}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
____________________ test_should_fail_with_wrong_extension _____________________

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_wrong_extension(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
>               generic_csv_to_db(
                    retrieve_file_path("wrongExtension.txt"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/wrongExtension.txt'
owner_id = 58, course_id = 17

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/wrongExtension.txt'
owner_id = 58, course_id = 17

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
>               raise WrongExtension
E               Functions.customExceptions.WrongExtension: Raised when the submitted file is not a csv or xlsx

Functions/genericImport.py:148: WrongExtension

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x11b6485b0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b648280>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 58}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b648ca0>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 58}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b648280>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b648ca0>
query = 'DELETE FROM `User` WHERE `User`.user_id = 58', args = {'user_id_1': 58}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b648ca0>
q = 'DELETE FROM `User` WHERE `User`.user_id = 58'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b649660>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 58', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b649660>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b649000>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b649660>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b649870>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_wrong_extension(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
                generic_csv_to_db(
                    retrieve_file_path("wrongExtension.txt"),
                    result["user_id"],
                    result["course_id"]
                )
            except Exception as e:
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 58}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:40,973 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 58}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 58}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
___________________ test_should_fail_with_not_enough_columns ___________________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/notEnoughColumns.csv'
owner_id = 59, course_id = 18

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/notEnoughColumns.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_not_enough_columns(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
>               generic_csv_to_db(
                    retrieve_file_path("notEnoughColumns.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:51: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/notEnoughColumns.csv'
owner_id = 59, course_id = 18

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/notEnoughColumns.csv'
owner_id = 59, course_id = 18

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x11ba560e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11ba56770>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 59}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11ba56b60>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 59}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11ba56770>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11ba56b60>
query = 'DELETE FROM `User` WHERE `User`.user_id = 59', args = {'user_id_1': 59}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11ba56b60>
q = 'DELETE FROM `User` WHERE `User`.user_id = 59'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11ba57a90>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 59', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11ba57a90>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11ba56d40>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11ba57a90>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11ba57220>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_not_enough_columns(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
                generic_csv_to_db(
                    retrieve_file_path("notEnoughColumns.csv"),
                    result["user_id"],
                    result["course_id"]
                )
            except Exception as e:
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 59}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:41,302 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 59}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 59}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
_______________ test_should_fail_with_misformatted_student_email _______________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/invalidStudentEmail.csv'
owner_id = 60, course_id = 19

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/invalidStudentEmail.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_misformatted_student_email(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
>               generic_csv_to_db(
                    retrieve_file_path("invalidStudentEmail.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/invalidStudentEmail.csv'
owner_id = 60, course_id = 19

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/invalidStudentEmail.csv'
owner_id = 60, course_id = 19

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x11b69eb60>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fd30>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 60}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b69f940>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 60}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fd30>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b69f940>
query = 'DELETE FROM `User` WHERE `User`.user_id = 60', args = {'user_id_1': 60}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b69f940>
q = 'DELETE FROM `User` WHERE `User`.user_id = 60'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69dab0>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 60', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69dab0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b69f6a0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69dab0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b69f1c0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_misformatted_student_email(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
                generic_csv_to_db(
                    retrieve_file_path("invalidStudentEmail.csv"),
                    result["user_id"],
                    result["course_id"]
                )
            except Exception as e:
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:75: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 60}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:41,705 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 60}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 60}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
__________________ test_valid_student_with_no_lms_id_in_table __________________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneStudentNoLMSID.csv'
owner_id = 61, course_id = 20

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneStudentNoLMSID.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_valid_student_with_no_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
>               message = generic_csv_to_db(
                    retrieve_file_path("oneStudentNoLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneStudentNoLMSID.csv'
owner_id = 61, course_id = 20

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneStudentNoLMSID.csv'
owner_id = 61, course_id = 20

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x11b4d93f0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b4d9420>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 61}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b4d9450>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 61}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b4d9420>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b4d9450>
query = 'DELETE FROM `User` WHERE `User`.user_id = 61', args = {'user_id_1': 61}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b4d9450>
q = 'DELETE FROM `User` WHERE `User`.user_id = 61'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b4daaa0>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 61', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b4daaa0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b4d9fc0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b4daaa0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b4d9c60>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_valid_student_with_no_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
                message = generic_csv_to_db(
                    retrieve_file_path("oneStudentNoLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )
                assert message is None, message # generic_csv_to_db() returns none when successful
    
                user = get_user_by_email("teststudent1@gmail.com")
    
                error_message = "generic_csv_to_db() did not correctly create the valid test student"
                assert user is not None, error_message
    
                user_id = get_user_user_id_by_email("teststudent1@gmail.com")
                user_courses = get_user_courses_by_user_id(user_id)
    
                error_message = "generic_csv_to_db() did not correctly enroll the valid test student in the test course"
                assert user_courses.__len__() == 1, error_message
    
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_course(result)
            except:
                delete_all_users_user_courses(result["course_id"])
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 61}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:42,037 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 61}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 61}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
___________________ test_valid_student_with_lms_id_in_table ____________________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneStudentWithLMSID.csv'
owner_id = 62, course_id = 21

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneStudentWithLMSID.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_valid_student_with_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
>               message = generic_csv_to_db(
                    retrieve_file_path("oneStudentWithLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneStudentWithLMSID.csv'
owner_id = 62, course_id = 21

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneStudentWithLMSID.csv'
owner_id = 62, course_id = 21

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x11aae9ae0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aae8e50>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 62}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11aae8c10>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 62}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aae8e50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aae8c10>
query = 'DELETE FROM `User` WHERE `User`.user_id = 62', args = {'user_id_1': 62}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aae8c10>
q = 'DELETE FROM `User` WHERE `User`.user_id = 62'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aae89a0>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 62', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aae89a0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11aae8b80>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aae89a0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11aae92d0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_valid_student_with_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(False)
                message = generic_csv_to_db(
                    retrieve_file_path("oneStudentWithLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )
    
                assert message is None, message # generic_csv_to_db() returns none when successful
    
                user = get_user_by_email("teststudent1@gmail.com")
    
                error_message = "generic_csv_to_db() did not correctly create the valid test student"
                assert user is not None, error_message
    
                error_message = "upload failed to assign lms_id attribute to student when expected."
                assert user.lms_id is not None, error_message
    
                user_id = get_user_user_id_by_email("teststudent1@gmail.com")
                user_courses = get_user_courses_by_user_id(user_id)
    
                error_message = "generic_csv_to_db() did not correctly enroll the valid test student in the test course"
                assert user_courses.__len__() == 1, error_message
    
                delete_all_users_user_courses(result["course_id"])
                error_message = "delete_one_admin_course() encountered an unexpected error!"
                delete_one_admin_course(result)
    
            except:
                delete_all_users_user_courses(result["course_id"])
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 62}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:42,406 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 62}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 62}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
____________________ test_valid_ta_with_no_lms_id_in_table _____________________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneTANoLMSID.csv'
owner_id = 63, course_id = 22

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneTANoLMSID.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_valid_ta_with_no_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(True)
>               message = generic_csv_to_db(
                    retrieve_file_path("oneTANoLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneTANoLMSID.csv'
owner_id = 63, course_id = 22

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneTANoLMSID.csv'
owner_id = 63, course_id = 22

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x11afc4580>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afc58d0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 63}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11afc5510>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 63}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afc58d0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11afc5510>
query = 'DELETE FROM `User` WHERE `User`.user_id = 63', args = {'user_id_1': 63}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11afc5510>
q = 'DELETE FROM `User` WHERE `User`.user_id = 63'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afc6440>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 63', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afc6440>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11afc5450>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afc6440>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11afc5300>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_valid_ta_with_no_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(True)
                message = generic_csv_to_db(
                    retrieve_file_path("oneTANoLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )
                assert message is None, message # generic_csv_to_db() returns none when successful
                user = get_user_by_email("testTA1@gmail.com")
    
                error_message = "generic_csv_to_db() did not correctly create the valid test TA"
                assert user is not None, error_message
    
                user_id = get_user_user_id_by_email("testTA1@gmail.com")
                user_courses = get_user_courses_by_user_id(user_id)
    
                error_message = "generic_csv_to_db() did not correctly enroll the valid test TA in the test course"
                assert user_courses.__len__() == 1, error_message
    
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_course(result)
            except:
                delete_all_users_user_courses(result["course_id"])
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 63}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:42,765 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 63}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 63}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
______________________ test_valid_ta_with_lms_id_in_table ______________________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneTAWithLMSID.csv'
owner_id = 64, course_id = 23

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneTAWithLMSID.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_valid_ta_with_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(True)
>               message = generic_csv_to_db(
                    retrieve_file_path("oneTAWithLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:182: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneTAWithLMSID.csv'
owner_id = 64, course_id = 23

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/oneTAWithLMSID.csv'
owner_id = 64, course_id = 23

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x10f52dc30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f52f370>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 64}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f52eef0>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 64}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f52f370>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f52eef0>
query = 'DELETE FROM `User` WHERE `User`.user_id = 64', args = {'user_id_1': 64}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f52eef0>
q = 'DELETE FROM `User` WHERE `User`.user_id = 64'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f52f850>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 64', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f52f850>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f52efb0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f52f850>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f52edd0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_valid_ta_with_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(True)
                message = generic_csv_to_db(
                    retrieve_file_path("oneTAWithLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )
                assert message is None, message # generic_csv_to_db() returns none when successful
    
                user = get_user_by_email("testTA1@gmail.com")
    
                error_message = "generic_csv_to_db() did not correctly create the valid test TA"
                assert user is not None, error_message
    
                error_message = "upload failed to assign lms_id attribute to TA when expected."
                assert user.lms_id is not None, error_message
    
                user_id = get_user_user_id_by_email("testTA1@gmail.com")
                user_courses = get_user_courses_by_user_id(user_id)
    
                error_message = "generic_csv_to_db() did not correctly enroll the valid test TA in the test course"
                assert user_courses.__len__() == 1, error_message
    
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_course(result)
            except:
                delete_all_users_user_courses(result["course_id"])
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 64}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:43,112 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 64}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 64}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
______________ test_valid_student_and_ta_with_no_lms_id_in_table _______________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/StudentAndTANoLMSID.csv'
owner_id = 65, course_id = 24

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/StudentAndTANoLMSID.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_valid_student_and_ta_with_no_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(True)
>               message = generic_csv_to_db(
                    retrieve_file_path("StudentAndTANoLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/StudentAndTANoLMSID.csv'
owner_id = 65, course_id = 24

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/StudentAndTANoLMSID.csv'
owner_id = 65, course_id = 24

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x11b3b9060>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3b8370>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 65}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b3ba350>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 65}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3b8370>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b3ba350>
query = 'DELETE FROM `User` WHERE `User`.user_id = 65', args = {'user_id_1': 65}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b3ba350>
q = 'DELETE FROM `User` WHERE `User`.user_id = 65'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3b87c0>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 65', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3b87c0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b3b8280>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3b87c0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b3ba170>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_valid_student_and_ta_with_no_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(True)
                message = generic_csv_to_db(
                    retrieve_file_path("StudentAndTANoLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )
                assert message is None, message # generic_csv_to_db() returns none when successful
                user = get_user_by_email("testTA1@gmail.com")
    
                error_message = "generic_csv_to_db() did not correctly create the valid test TA"
                assert user is not None, error_message
    
                user = get_user_by_email("teststudent1@gmail.com")
    
                error_message = "generic_csv_to_db() did not correctly create the valid test student"
                assert user is not None, error_message
    
                user_id = get_user_user_id_by_email("testTA1@gmail.com")
                user_courses = get_user_courses_by_user_id(user_id)
    
                error_message = "generic_csv_to_db() did not correctly enroll the valid test TA in the test course"
                assert user_courses.__len__() == 1, error_message
    
                user_id = get_user_user_id_by_email("teststudent1@gmail.com")
                user_courses = get_user_courses_by_user_id(user_id)
    
                error_message = "generic_csv_to_db() did not correctly enroll the valid test student in the test course"
                assert user_courses.__len__() == 1, error_message
    
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_course(result)
            except:
                delete_all_users_user_courses(result["course_id"])
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:247: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 65}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:43,419 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 65}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 65}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
________ test_valid_students_and_tas_with__and_without_lms_id_in_table _________

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/StudentAndTAWithLMSID.csv'
owner_id = 66, course_id = 25

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
>               student_csv = open(user_file, mode='r', encoding='utf-8-sig')
E               FileNotFoundError: [Errno 2] No such file or directory: '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/StudentAndTAWithLMSID.csv'

Functions/genericImport.py:157: FileNotFoundError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_valid_students_and_tas_with__and_without_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(True)
>               message = generic_csv_to_db(
                    retrieve_file_path("StudentAndTAWithLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )

Functions/test_files/test_genericImport.py:255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/StudentAndTAWithLMSID.csv'
owner_id = 66, course_id = 25

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
                raise FileNotFound
    
            # Renamed `reader` -> `roster`.
            roster: list[list[str]] = list(itertools.tee(csv.reader(student_csv))[0])
    
            if not roster:
                raise EmptyFile()
    
            # For keeping students in a "queue" as we are parsing
            # the file. During parsing, we add the relevant information
            # to this list (first_name, last_name, email, role_id, lms_id).
            students: list[tuple] = []
    
            # Track duplicate checks
            seen_emails: dict[str, int] = {}
            seen_lms_ids: dict[str, int] = {}
            valid_roles = ["Student", "TA", "Instructor"]
    
            for row in range(0, len(roster)):
                person_attribs: list[str] = roster[row]
    
                # Skip empty rows
                if len(person_attribs) == 0:
                    continue
    
                MIN_PERSON_ATTRIBS_COUNT: int = 3  # Checking for 3 for: FN LN, email, role
    
                MAX_PERSON_ATTRIBS_COUNT: int = 4  # Checking for 4 for: FN LN, email, role, (optional) LMS ID
    
                if len(person_attribs) < MIN_PERSON_ATTRIBS_COUNT:
                    raise NotEnoughColumns(row + 1, MIN_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                if len(person_attribs) > MAX_PERSON_ATTRIBS_COUNT:
                    raise TooManyColumns(row + 1, MAX_PERSON_ATTRIBS_COUNT, len(person_attribs))
    
                name: str = person_attribs[0].strip()  # FN,LN
    
                # Validate name format
                if ',' not in name:
                    raise InvalidNameFormat(row + 1, name)
    
                last_name: str = name.split(',')[0].strip()
                first_name: str = name.split(',')[1].strip()
    
                if not last_name or not first_name:
                    raise InvalidNameFormat(row + 1, name)
    
                email: str = person_attribs[1].strip()
    
                # Check for duplicate emails
                if email in seen_emails:
                    raise DuplicateEmail(email, [seen_emails[email], row + 1])
                seen_emails[email] = row + 1
    
                role: str = person_attribs[2].strip()
    
                # Validate role before conversion
                if role not in valid_roles:
                    raise InvalidRole(row + 1, role, valid_roles)
    
                lms_id: int|None = None
    
                role = helper_str_to_int_role(role)
                role = get_role(role)
                role_id = role.role_id
    
                # If the len of person_attribs == 4, then the LMS ID is present.
                if len(person_attribs) == 4:
                    lms_id = person_attribs[3].strip()
                    if lms_id:  # Only validate if not empty
                        if not lms_id.isdigit():
                            raise InvalidLMSID(row + 1, lms_id)
                        if lms_id in seen_lms_ids:
                            raise DuplicateLMSID(lms_id, [seen_lms_ids[lms_id], row + 1])
                        seen_lms_ids[lms_id] = row + 1
    
                if not helper_verify_email_syntax(email):
                    raise InvalidEmail(row + 1, email)
    
                students.append((first_name, last_name, email, role_id, lms_id))
    
            for first_name, last_name, email, role_id, lms_id in students:
                __add_user(owner_id, course_id, first_name, last_name, email, role_id, lms_id)
    
            student_csv.close()
    
            delete_xlsx(user_file, is_xlsx)
    
            return None
    
        except Exception as e:
            if student_csv is not None:
                student_csv.close()
    
            if is_xlsx is not None:
                delete_xlsx(user_file, is_xlsx)
    
>           raise e

Functions/genericImport.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_file = '/Users/sahammond/rubricapp/BackEndFlask/Functions/sample_files/StudentAndTAWithLMSID.csv'
owner_id = 66, course_id = 25

    def generic_csv_to_db(user_file: str, owner_id: int, course_id: int) -> None|str:
        """
        Description:
        Takes a csv file and creates users of any type (student, TA, etc.)
        and adds them to the database.
    
        Parameters:
        user_file: str: The path to the csv file.
        owner_id: int:  The user_id of the owner of the course.
        course_id: int: The course_id of the course to add the users to.
    
        Returns:
        None: On success.
        """
        student_csv: None|object = None
    
        is_xlsx: bool|None = None
    
        try:
            if not user_file.endswith('.csv') and not user_file.endswith('.xlsx'):
                raise WrongExtension
    
            # Determine if file is .xlsx.
            is_xlsx = user_file.endswith('.xlsx')
    
            if is_xlsx:
                user_file = xlsx_to_csv(user_file)
    
            try:
                student_csv = open(user_file, mode='r', encoding='utf-8-sig')
    
            except FileNotFoundError:
                delete_xlsx(user_file, is_xlsx)
    
>               raise FileNotFound
E               Functions.customExceptions.FileNotFound: File not found or does not exist!

Functions/genericImport.py:162: FileNotFound

During handling of the above exception, another exception occurred:

self = <sqlalchemy.engine.base.Connection object at 0x11baaa680>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11baab310>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e2d10>
parameters = [{'user_id_1': 66}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11baab790>
statement = 'DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s'
parameters = {'user_id_1': 66}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11baab310>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11baab790>
query = 'DELETE FROM `User` WHERE `User`.user_id = 66', args = {'user_id_1': 66}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11baab790>
q = 'DELETE FROM `User` WHERE `User`.user_id = 66'

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11baaae30>
sql = b'DELETE FROM `User` WHERE `User`.user_id = 66', unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11baaae30>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11baab6d0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11baaae30>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11baab8b0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_valid_students_and_tas_with__and_without_lms_id_in_table(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_course(True)
                message = generic_csv_to_db(
                    retrieve_file_path("StudentAndTAWithLMSID.csv"),
                    result["user_id"],
                    result["course_id"]
                )
                assert message is None, message # generic_csv_to_db() returns none when successful
                user = get_user_by_email("testTA1@gmail.com")
    
                error_message = "generic_csv_to_db() did not correctly create the valid test TA"
                assert user is not None, error_message
    
                error_message = "upload failed to assign lms_id attribute to TA when expected."
                assert user.lms_id is not None, error_message
    
                user = get_user_by_email("teststudent1@gmail.com")
    
                error_message = "generic_csv_to_db() did not correctly create the valid test student"
                assert user is not None, error_message
    
                error_message = "upload failed to assign lms_id attribute to student when expected."
                assert user.lms_id is not None, error_message
    
                user_id = get_user_user_id_by_email("testTA1@gmail.com")
                user_courses = get_user_courses_by_user_id(user_id)
    
                error_message = "generic_csv_to_db() did not correctly enroll the valid test TA in the test course"
                assert user_courses.__len__() == 1, error_message
    
                user_id = get_user_user_id_by_email("teststudent1@gmail.com")
                user_courses = get_user_courses_by_user_id(user_id)
    
                error_message = "generic_csv_to_db() did not correctly enroll the valid test student in the test course"
                assert user_courses.__len__() == 1, error_message
    
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_course(result)
            except:
                delete_all_users_user_courses(result["course_id"])
>               delete_one_admin_course(result)

Functions/test_files/test_genericImport.py:293: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
Functions/test_files/PopulationFunctions.py:80: in delete_one_admin_course
    user = delete_user(result["user_id"])
models/utility.py:118: in wrapper
    raise e
models/utility.py:114: in wrapper
    return f(*args, *kwargs)
models/user.py:373: in delete_user
    User.query.filter_by(user_id=user_id).delete()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/query.py:3182: in delete
    self.session.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2232: in execute
    return self._execute_internal(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:2127: in _execute_internal
    result: Result[Any] = compile_state_cls.orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/bulk_persistence.py:1916: in orm_execute_statement
    return super().orm_execute_statement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/context.py:292: in orm_execute_statement
    result = conn.execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: in execute
    return meth(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: in _execute_on_connection
    return connection._execute_clauseelement(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: in _execute_clauseelement
    ret = self._execute_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: in _execute_context
    return self._exec_single_context(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: in _exec_single_context
    self._handle_dbapi_exception(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: in _exec_single_context
    self.dialect.do_execute(
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: in do_execute
    cursor.execute(statement, parameters)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: in execute
    result = self._query(query)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: in _query
    conn.query(q)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: in query
    self._affected_rows = self._read_query_result(unbuffered=unbuffered)
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: in _read_query_result
    result.read()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: in read
    first_packet = self.connection._read_packet()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: in _read_packet
    packet.raise_for_error()
/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: in raise_for_error
    err.raise_mysql_exception(self._data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b'\xff\xab\x05#23000Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)'

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
E       [SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
E       [parameters: {'user_id_1': 66}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:43,774 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 66}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1451, 'Cannot delete or update a parent row: a foreign key constraint fails (`rubricapp`.`course`, CONSTRAINT `course_ibfk_1` FOREIGN KEY (`admin_id`) REFERENCES `user` (`user_id`) ON DELETE RESTRICT)')
[SQL: DELETE FROM `User` WHERE `User`.user_id = %(user_id_1)s]
[parameters: {'user_id_1': 66}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
___________________________ test_one_ta_ten_students ___________________________

self = <sqlalchemy.engine.base.Connection object at 0x10f7526e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f751c00>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f751ba0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f751c00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f751ba0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...c13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.086778')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f751ba0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...c13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.086778')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f753a00>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...c13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.086778')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f753a00>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f752a70>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f753a00>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f751de0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_one_ta_ten_students(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_randAssignTeams.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4554306416)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f7533a0>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f16c480>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f16c480>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f16c480>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f16c480>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f16c480>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f16c480>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f7533a0>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f7533a0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x10f753790>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f7533a0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f753670>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f753670>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x10f257df0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f753670>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f753670>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x10f255d90>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f7526e0>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x10f7526e0>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f7526e0>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f7526e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11ab8c1c0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f751c00>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f7526e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f751c00>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f7526e0>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x10f751ba0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f751c00>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f7526e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f751c00>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f751ba0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f751c00>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f751ba0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...c13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.086778')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f751ba0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...c13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.086778')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f753a00>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...c13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.086778')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f753a00>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f752a70>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f753a00>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f751de0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$lafineqve8B2JIDt$00e0cc13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 86778)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_one_ta_ten_students(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                students = create_users(result["course_id"], result["admin_id"], 10)
    
                random = RandomAssignTeams(
                    result["observer_id"],
                    result["course_id"]
                )
                random_assign_teams_created = get_team_by_course_id(result["course_id"])
    
                error_message = "RandomAssignTeams() did not correctly create and assign 3 teams"
                assert random_assign_teams_created.__len__() == 3, error_message
    
                total_team_users = 0
                teams = []
                for team in random_assign_teams_created:
                    teams.append(team)
                    team_users = get_team_users_by_team_id(team.team_id)
    
                    error_message = "RandomAssignTeams() did not correctly assign a max size per team of 4 students"
                    assert team_users.__len__() <= 4, error_message
    
                    total_team_users += team_users.__len__()
    
                error_message = "RandomAssignTeams() did not correctly assign all 10 test students to 3 teams!"
                assert total_team_users == 10, error_message
    
                error_message = "RandomAssignTeams() did not correctly assing the test ta to all the 3 teams!"
                assert user_is_only_assigned_to_teams(result["observer_id"], teams), error_message
    
                delete_all_teams_team_members(result["course_id"])
                delete_users(students)
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_randAssignTeams.py:52: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:44,090 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$lafineqve8B2JIDt$00e0cc13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 86778)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$lafineqve8B2JIDt$00e0cc13dbb5c199214281d07ea9a917e2383194f4b77679659ea9d5325acceb', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 86778)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
___________________________ test_no_ta_ten_students ____________________________

self = <sqlalchemy.engine.base.Connection object at 0x11b3be500>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3bd660>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b3bdb40>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3bd660>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b3bdb40>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...11eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.466895')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b3bdb40>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...11eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.466895')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3beec0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...11eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.466895')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3beec0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b3be5c0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3beec0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b3be4a0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_no_ta_ten_students(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course(False)

Functions/test_files/test_randAssignTeams.py:67: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = False, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4751881360)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b3bee90>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad48e80>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad48e80>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad48e80>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad48e80>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad48e80>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ad48e80>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b3bee90>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b3bee90>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b3bf220>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b3bee90>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b3bf190>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b3bf190>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x10f66f290>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b3bf190>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b3bf190>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x10f66e420>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3be500>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b3be500>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3be500>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3be500>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11ab4fa00>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3bd660>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3be500>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3bd660>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3be500>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b3bdb40>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3bd660>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3be500>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3bd660>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b3bdb40>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3bd660>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b3bdb40>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...11eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.466895')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b3bdb40>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...11eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.466895')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3beec0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...11eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.466895')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3beec0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b3be5c0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b3beec0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b3be4a0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$TUI3giAeT4kDteKc$1f36411eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 466895)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_no_ta_ten_students(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course(False)
                students = create_users(result["course_id"], result["admin_id"], 10)
    
                random = RandomAssignTeams(
                    result["observer_id"],
                    result["course_id"]
                )
    
                random_assign_teams_created = get_team_by_course_id(result["course_id"])
    
                error_message = "RandomAssignTeams() did not correctly create and assign 3 teams"
                assert random_assign_teams_created.__len__() == 3, error_message
    
                total_team_users = 0
                teams = []
                for team in random_assign_teams_created:
                    teams.append(team)
                    team_users = get_team_users_by_team_id(team.team_id)
    
                    error_message = "RandomAssignTeams() did not correctly assign a max size per team of 4 students"
                    assert team_users.__len__() <= 4, error_message
    
                    total_team_users += team_users.__len__()
    
                error_message = "RandomAssignTeams() did not correctly assign all 10 test students to 3 teams!"
                assert total_team_users == 10, error_message
    
                error_message = "RandomAssignTeams() did not correctly assing the test ta to all the 3 teams!"
                assert user_is_only_assigned_to_teams(result["observer_id"], teams), error_message
    
                delete_all_teams_team_members(result["course_id"])
                delete_users(students)
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_ta_student_course(result, False)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_randAssignTeams.py:103: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:44,469 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$TUI3giAeT4kDteKc$1f36411eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 466895)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$TUI3giAeT4kDteKc$1f36411eaa253012f1167af89c295d69c49c00c2963a76db4534b517468bb945', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 466895)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
__________________________ test_ten_tas_ten_students ___________________________

self = <sqlalchemy.engine.base.Connection object at 0x11b495ea0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b495090>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b494f70>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b495090>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b494f70>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...8a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.829255')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b494f70>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...8a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.829255')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b496bc0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...8a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.829255')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b496bc0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b495ed0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b496bc0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b4959f0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_ten_tas_ten_students(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_randAssignTeams.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4752763168)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b496950>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b5fa680>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b5fa680>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b5fa680>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b5fa680>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b5fa680>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b5fa680>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b496950>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b496950>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b4968f0>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b496950>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b496980>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b496980>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x10f5ad1c0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b496980>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b496980>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x10f5af6f0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b495ea0>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b495ea0>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b495ea0>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b495ea0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11ab0e0e0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b495090>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b495ea0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b495090>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b495ea0>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b494f70>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b495090>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b495ea0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b495090>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b494f70>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b495090>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b494f70>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...8a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.829255')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b494f70>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...8a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.829255')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b496bc0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...8a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:44.829255')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b496bc0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b495ed0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b496bc0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b4959f0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$SNzsm8WonJ1ifNma$be3588a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 829255)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_ten_tas_ten_students(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                tas = create_users(result["course_id"], result["admin_id"], 10, 4)
                students = create_users(result["course_id"], result["admin_id"], 10)
    
                random = RandomAssignTeams(
                    result["observer_id"],
                    result["course_id"],
                    1
                )
    
                user_courses = get_user_courses_by_course_id(result["course_id"])
                all_tas = filter_users_by_role(user_courses, 4)
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "RandomAssignTeams() did not correctly create and assign 10 teams"
                assert teams.__len__() == 10, error_message
    
                total_team_users = 0
                for team in teams:
                    error_message = "RandomAssignTeams() did not correctly assign a ta to a team!"
                    assert ta_is_assigned_to_team(all_tas, team), error_message
    
                    team_users = get_team_users_by_team_id(team.team_id)
    
                    error_message = "RandomAssignTeams() did not correctly assign a max size per team of 1 student"
                    assert team_users.__len__() == 1, error_message
                    total_team_users += team_users.__len__()
    
                error_message = "RandomAssignTeams() did not correctly assign all 10 test students to 10 teams!"
                assert total_team_users == 10, error_message
    
                delete_all_teams_team_members(result["course_id"])
                delete_users(tas)
                delete_users(students)
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_randAssignTeams.py:156: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:44,832 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$SNzsm8WonJ1ifNma$be3588a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 829255)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$SNzsm8WonJ1ifNma$be3588a71fa1c0daf37573449f6dbab28a19acbc9fb22fb5a76cbd435deeb827', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 44, 829255)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
____________________ test_TA_true_but_no_TAs_recorded_error ____________________

self = <sqlalchemy.engine.base.Connection object at 0x11afb3b50>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afb2d10>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11afb2bf0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afb2d10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11afb2bf0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.227545')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11afb2bf0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.227545')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afb1a80>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.227545')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afb1a80>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11afb3af0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afb1a80>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11afb3c40>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_TA_true_but_no_TAs_recorded_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course(True, True)

Functions/test_files/test_randAssignTeams.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = True, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4747632384)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11afb1fc0>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae8d9c0>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae8d9c0>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae8d9c0>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae8d9c0>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae8d9c0>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae8d9c0>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11afb1fc0>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11afb1fc0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11afb1900>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11afb1fc0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11afb1e10>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11afb1e10>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11abd1000>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11afb1e10>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11afb1e10>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11abd1930>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11afb3b50>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11afb3b50>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11afb3b50>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11afb3b50>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f5a3a60>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afb2d10>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11afb3b50>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afb2d10>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11afb3b50>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11afb2bf0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afb2d10>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11afb3b50>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afb2d10>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11afb2bf0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11afb2d10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11afb2bf0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.227545')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11afb2bf0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.227545')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afb1a80>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.227545')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afb1a80>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11afb3af0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11afb1a80>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11afb3c40>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$dyNt0mpP6NRl0qQe$a2ed2481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 45, 227545)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_TA_true_but_no_TAs_recorded_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course(True, True)
                try:
                    random = RandomAssignTeams(
                        result["observer_id"],
                        result["course_id"]
                    )
                    assert False, "Should not reach this line"
    
                except Exception as e:
                    assert isinstance(e, NoTAsListed), f"Expected NoTAsListed, got {e}"
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "RandomAssignTeams() should not have made and enrolled any test teams in the test course!"
                assert teams.__len__() == 0, error_message
    
                delete_all_teams_team_members(result["course_id"])
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_randAssignTeams.py:191: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:45,232 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$dyNt0mpP6NRl0qQe$a2ed2481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 45, 227545)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$dyNt0mpP6NRl0qQe$a2ed2481a98c891fa5b187f95fa9d30a03af0b92e2e0056ff6bac4f54eca1cb4', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 45, 227545)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
_______________________ test_no_students_in_course_error _______________________

self = <sqlalchemy.engine.base.Connection object at 0x11b3011b0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3003a0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b300280>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3003a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b300280>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.565947')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b300280>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.565947')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b301ed0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.565947')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b301ed0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b3011e0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b301ed0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b300d00>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_no_students_in_course_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course(True, False, True)

Functions/test_files/test_randAssignTeams.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = True

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4751105072)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b301c60>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8e8ec0>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8e8ec0>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8e8ec0>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8e8ec0>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8e8ec0>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8e8ec0>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b301c60>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b301c60>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b301c00>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b301c60>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b301c90>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b301c90>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11ab3c510>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b301c90>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b301c90>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11ab3dee0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3011b0>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b3011b0>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3011b0>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3011b0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f5bc3a0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3003a0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3011b0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3003a0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3011b0>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b300280>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3003a0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b3011b0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3003a0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b300280>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b3003a0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b300280>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.565947')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b300280>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.565947')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b301ed0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:45.565947')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b301ed0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b3011e0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b301ed0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b300d00>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$yHSU4ItzvfmliBTs$8b3ad80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 45, 565947)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_no_students_in_course_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course(True, False, True)
    
                try:
                    random = RandomAssignTeams(
                        result["observer_id"],
                        result["course_id"]
                    )
                    assert False, "Should not reach this line"
    
                except Exception as e:
                    assert isinstance(e, NoStudentsInCourse), f"Expected NoStudentsInCourse but got {e}"
    
                delete_all_teams_team_members(result["course_id"])
                delete_all_users_user_courses(result["course_id"])
                delete_one_admin_ta_student_course(result)
    
            except:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_randAssignTeams.py:220: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:45,568 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$yHSU4ItzvfmliBTs$8b3ad80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 45, 565947)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$yHSU4ItzvfmliBTs$8b3ad80119edb04d55e8dd2c49420c42d5d0a7d7ca58fd473bf14bc99f0fd84e', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 45, 565947)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
_________________ test_should_fail_with_non_existant_ta_email __________________

self = <sqlalchemy.engine.base.Connection object at 0x11b488370>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b488250>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b48add0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b488250>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b48add0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...5c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.003880')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b48add0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...5c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.003880')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b489960>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...5c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.003880')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b489960>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b489360>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b489960>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b48a410>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_non_existant_ta_email(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamBulkUpload.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4752708256)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b48a6e0>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aa6a8c0>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aa6a8c0>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aa6a8c0>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aa6a8c0>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aa6a8c0>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aa6a8c0>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b48a6e0>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b48a6e0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b489f60>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b48a6e0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b489150>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b489150>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11abaa420>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b489150>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b489150>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11abaa030>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b488370>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b488370>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b488370>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b488370>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f682b00>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b488250>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b488370>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b488250>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b488370>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b48add0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b488250>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b488370>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b488250>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b48add0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b488250>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b48add0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...5c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.003880')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b48add0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...5c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.003880')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b489960>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...5c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.003880')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b489960>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b489360>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b489960>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b48a410>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$fE01aiFPAw3JIvnP$86fb55c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 3880)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_non_existant_ta_email(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                team_bulk_upload(
                    retrieve_file_path("f-add-1-team-non-existant-ta-email.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
                error_message = "student_team_to_db() did not correctly return NonExistentTA.error"
                assert False, error_message
            except UserDoesNotExist as e:
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
                delete_all_users_user_courses(result["course_id"])
                assert True
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamBulkUpload.py:38: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:46,008 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$fE01aiFPAw3JIvnP$86fb55c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 3880)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$fE01aiFPAw3JIvnP$86fb55c3910143b939263013df9d1812c4881ffe181e660fc5f969511060f933', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 3880)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
_ test_should_fail_with_suspected_misformatting_error_given_misformatted_ta_email _

self = <sqlalchemy.engine.base.Connection object at 0x11aec8d30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aec8670>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11aec86d0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aec8670>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aec86d0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...3dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.368789')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aec86d0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...3dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.368789')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aeca380>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...3dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.368789')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aeca380>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11aec8dc0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aeca380>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11aec8e20>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_suspected_misformatting_error_given_misformatted_ta_email(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamBulkUpload.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4746680000)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11aec95d0>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aea7f80>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aea7f80>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aea7f80>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aea7f80>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aea7f80>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11aea7f80>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11aec95d0>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11aec95d0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11aeca650>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11aec95d0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11aec9ff0>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11aec9ff0>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11abe91c0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11aec9ff0>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11aec9ff0>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11abe9150>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aec8d30>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11aec8d30>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aec8d30>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aec8d30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f682fe0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aec8670>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aec8d30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aec8670>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aec8d30>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11aec86d0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aec8670>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aec8d30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aec8670>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11aec86d0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aec8670>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aec86d0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...3dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.368789')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aec86d0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...3dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.368789')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aeca380>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...3dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.368789')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aeca380>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11aec8dc0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aeca380>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11aec8e20>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$quJAd8H7gvK6bfkp$e7ae03dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 368789)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_suspected_misformatting_error_given_misformatted_ta_email(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                team_bulk_upload(
                    retrieve_file_path("f-add-3-people-misformatted-ta-email.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
                error_message = "student_team_to_db() did not correctly return SuspectedMisformatting.error"
                assert False, error_message
            except SuspectedMisformatting as e:
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
                delete_all_users_user_courses(result["course_id"])
                assert True
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamBulkUpload.py:61: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:46,371 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$quJAd8H7gvK6bfkp$e7ae03dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 368789)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$quJAd8H7gvK6bfkp$e7ae03dd70509c5a8041623bc0a9ec0e3291f65beb8992f4a27dcad11b285fae', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 368789)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
___________________ test_should_fail_with_empty_team_members ___________________

self = <sqlalchemy.engine.base.Connection object at 0x10f3e63e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e4ac0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f3e6620>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e4ac0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f3e6620>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...f8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.762634')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f3e6620>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...f8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.762634')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e55a0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...f8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.762634')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e55a0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f3e74f0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e55a0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f3e7550>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_empty_team_members(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamBulkUpload.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4550714192)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f3e57e0>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11af3e940>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11af3e940>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11af3e940>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11af3e940>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11af3e940>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11af3e940>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f3e57e0>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f3e57e0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x10f3e5510>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f3e57e0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f3e5900>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f3e5900>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x10f5a59a0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f3e5900>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f3e5900>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x10f5a45f0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e63e0>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x10f3e63e0>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e63e0>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e63e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f6852a0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e4ac0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e63e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e4ac0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e63e0>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x10f3e6620>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e4ac0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e63e0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e4ac0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f3e6620>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e4ac0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f3e6620>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...f8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.762634')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f3e6620>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...f8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.762634')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e55a0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...f8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:46.762634')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e55a0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f3e74f0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e55a0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f3e7550>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$JrezhGBdOf0z7wps$0cfaaf8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 762634)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_empty_team_members(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                res = team_bulk_upload(
                    retrieve_file_path("f-no-students-in-team.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
                error_message = "student_team_to_db() did not correctly return EmptyTeamMembers.error"
                assert False, error_message
            except EmptyTeamMembers as e:
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
                delete_all_users_user_courses(result["course_id"])
                assert True
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamBulkUpload.py:84: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:46,764 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$JrezhGBdOf0z7wps$0cfaaf8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 762634)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$JrezhGBdOf0z7wps$0cfaaf8e5edadbc67dea6929520c52db9555be3ecf6aac21ee9461c0e7bedb3e', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 46, 762634)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
______ test_should_fail_with_file_not_found_error_given_non_existent_file ______

self = <sqlalchemy.engine.base.Connection object at 0x11b8dcdf0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8dfc10>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b8dfb20>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8dfc10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b8dfb20>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.128616')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b8dfb20>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.128616')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8df100>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.128616')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8df100>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b8df7f0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8df100>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b8dd480>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_file_not_found_error_given_non_existent_file(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamBulkUpload.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4757243024)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b8de6e0>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8d5e40>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8d5e40>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8d5e40>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8d5e40>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8d5e40>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b8d5e40>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b8de6e0>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b8de6e0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b8dd360>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b8de6e0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b8df580>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b8df580>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11ae220a0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b8df580>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b8df580>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11ae22ea0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8dcdf0>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b8dcdf0>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8dcdf0>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8dcdf0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f679cc0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8dfc10>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8dcdf0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8dfc10>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8dcdf0>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b8dfb20>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8dfc10>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8dcdf0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8dfc10>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b8dfb20>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8dfc10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b8dfb20>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.128616')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b8dfb20>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.128616')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8df100>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.128616')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8df100>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b8df7f0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8df100>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b8dd480>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$jj4l9G0GbaSf86ZL$cbbdf6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 128616)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_fail_with_file_not_found_error_given_non_existent_file(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                try:
                    team_bulk_upload(
                        retrieve_file_path("NonExistentFile.csv"),
                        result["admin_id"],
                        result["course_id"]
                    )
                    assert False, "unreachable"
    
                except Exception as e:
                    assert isinstance(e, FileNotFoundError)
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should not assign a test team to a test course!"
                assert teams.__len__() == 0, error_message
    
                delete_one_admin_ta_student_course(result)
                delete_all_users_user_courses(result["course_id"])
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamBulkUpload.py:113: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:47,133 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$jj4l9G0GbaSf86ZL$cbbdf6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 128616)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$jj4l9G0GbaSf86ZL$cbbdf6a907147fba91f65e3e427abf923d819430d6a2dc86cc9abe8d190e0c53', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 128616)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
_____________________ test_should_pass_when_given_one_team _____________________

self = <sqlalchemy.engine.base.Connection object at 0x11b42fbb0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b42e140>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b42e1d0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b42e140>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b42e1d0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...50d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.532280')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b42e1d0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...50d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.532280')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b42ca90>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...50d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.532280')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b42ca90>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b42fbe0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b42ca90>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b42ed70>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_pass_when_given_one_team(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamBulkUpload.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4752327968)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b42c490>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b480d00>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b480d00>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b480d00>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b480d00>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b480d00>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b480d00>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b42c490>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b42c490>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b42cd90>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b42c490>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b42c820>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b42c820>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11aef6ff0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b42c820>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b42c820>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11aef7ed0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b42fbb0>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b42fbb0>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b42fbb0>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b42fbb0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f644a60>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b42e140>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b42fbb0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b42e140>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b42fbb0>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b42e1d0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b42e140>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b42fbb0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b42e140>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b42e1d0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b42e140>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b42e1d0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...50d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.532280')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b42e1d0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...50d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.532280')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b42ca90>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...50d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.532280')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b42ca90>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b42fbe0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b42ca90>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b42ed70>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$cJRXuAtE9hz6l2p4$391b450d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 532280)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_pass_when_given_one_team(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                team_bulk_upload(
                    retrieve_file_path("s-insert-1-team-1-ta.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should assign a test team to a test course!"
                assert teams.__len__() == 1, error_message
    
                user = get_user_by_email("teststudent1@gmail.com")
                error_message = "team_csv_to_db() should assign a test team to a test course!"
                assert user.first_name == "fname1", error_message
    
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
                delete_all_users_user_courses(result["course_id"])
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamBulkUpload.py:142: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:47,536 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$cJRXuAtE9hz6l2p4$391b450d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 532280)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$cJRXuAtE9hz6l2p4$391b450d209f85558a1d6323d8c81addbc131dd3f25b6bb571e844de21f9b665', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 532280)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
_________________ test_should_pass_when_given_two_teams_one_ta _________________

self = <sqlalchemy.engine.base.Connection object at 0x11abe7a90>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11abe5fc0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11abe43d0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11abe5fc0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11abe43d0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.891176')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11abe43d0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.891176')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11abe4100>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.891176')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11abe4100>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11abe6680>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11abe4100>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11abe73a0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_pass_when_given_two_teams_one_ta(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamBulkUpload.py:151: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4743657456)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11abe5750>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bbd6f40>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bbd6f40>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bbd6f40>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bbd6f40>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bbd6f40>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bbd6f40>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11abe5750>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11abe5750>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11abe7b80>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11abe5750>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11abe4d30>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11abe4d30>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11b3cfae0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11abe4d30>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11abe4d30>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11b3cc9e0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11abe7a90>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11abe7a90>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11abe7a90>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11abe7a90>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f5cb580>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11abe5fc0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11abe7a90>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11abe5fc0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11abe7a90>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11abe43d0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11abe5fc0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11abe7a90>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11abe5fc0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11abe43d0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11abe5fc0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11abe43d0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.891176')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11abe43d0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.891176')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11abe4100>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:47.891176')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11abe4100>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11abe6680>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11abe4100>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11abe73a0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$twFSVyyXEvYWsupZ$86c26021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 891176)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_pass_when_given_two_teams_one_ta(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                team_bulk_upload(
                    retrieve_file_path("s-insert-2-teams-1-ta.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should assign a test team to a test course!"
                assert teams.__len__() == 2, error_message
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
                delete_all_users_user_courses(result["course_id"])
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamBulkUpload.py:167: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:47,894 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$twFSVyyXEvYWsupZ$86c26021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 891176)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$twFSVyyXEvYWsupZ$86c26021c1636de84d0db71b4764ca4873e66f536570a828b4516823a7844689', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 47, 891176)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
________________ test_should_pass_when_given_three_teams_one_ta ________________

self = <sqlalchemy.engine.base.Connection object at 0x11b69eb30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fe80>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b69f580>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fe80>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b69f580>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.311092')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b69f580>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.311092')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69df00>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.311092')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69df00>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b69d780>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69df00>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b69ed40>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_pass_when_given_three_teams_one_ta(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamBulkUpload.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4754883536)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b69eda0>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bcb0f40>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bcb0f40>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bcb0f40>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bcb0f40>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bcb0f40>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bcb0f40>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b69eda0>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b69eda0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b69e290>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b69eda0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b69fca0>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b69fca0>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11aee77d0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b69fca0>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b69fca0>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11aee52a0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b69eb30>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b69eb30>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b69eb30>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b69eb30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f5907c0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fe80>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b69eb30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fe80>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b69eb30>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b69f580>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fe80>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b69eb30>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fe80>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b69f580>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b69fe80>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b69f580>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.311092')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b69f580>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.311092')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69df00>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.311092')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69df00>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b69d780>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b69df00>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b69ed40>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$viyO3Uko6QjbgsaR$6eaaf6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 48, 311092)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_pass_when_given_three_teams_one_ta(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                team_bulk_upload(
                    retrieve_file_path("s-insert-3-teams-1-ta.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should assign a test team to a test course!"
                assert teams.__len__() == 3, error_message
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
                delete_all_users_user_courses(result["course_id"])
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamBulkUpload.py:192: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:48,316 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$viyO3Uko6QjbgsaR$6eaaf6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 48, 311092)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$viyO3Uko6QjbgsaR$6eaaf6b24ce2b92fda97f11c1acb4525fad6c7911cfe650259c697e7e34501fe', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 48, 311092)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
__________________ test_should_pass_when_given_2_teams_2_tas ___________________

self = <sqlalchemy.engine.base.Connection object at 0x11b67ac20>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b67a5c0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b6792d0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b67a5c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b6792d0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.695907')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b6792d0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.695907')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b67bf70>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.695907')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b67bf70>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b679ba0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b67bf70>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b67b5e0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_should_pass_when_given_2_teams_2_tas(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_two_admin_two_ta_student_course()

Functions/test_files/test_teamBulkUpload.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_two_admin_two_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:175: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4754737328)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b67a500>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11afefe80>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11afefe80>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11afefe80>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11afefe80>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11afefe80>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11afefe80>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b67a500>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b67a500>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b67b160>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b67a500>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b67a0e0>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b67a0e0>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11aab3450>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b67a0e0>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b67a0e0>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11aab3140>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b67ac20>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b67ac20>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b67ac20>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b67ac20>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x10f600400>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b67a5c0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b67ac20>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b67a5c0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b67ac20>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b6792d0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b67a5c0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b67ac20>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b67a5c0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b6792d0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b67a5c0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b6792d0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.695907')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b6792d0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.695907')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b67bf70>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:48.695907')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b67bf70>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b679ba0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b67bf70>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b67b5e0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$5kFbdpBtHDlzCIzK$e78b6eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 48, 695907)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_should_pass_when_given_2_teams_2_tas(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_two_admin_two_ta_student_course()
                team_bulk_upload(
                    retrieve_file_path("s-insert-2-teams-2-tas.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should assign a test team to a test course!"
                assert teams.__len__() == 2, error_message
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
                delete_all_users_user_courses(result["course_id"])
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamBulkUpload.py:217: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:48,697 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$5kFbdpBtHDlzCIzK$e78b6eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 48, 695907)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$5kFbdpBtHDlzCIzK$e78b6eec82def4b82274730366cdb211e8f47ff0ee7cf04ccc508f614cc008f6', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 48, 695907)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
____________________ test_valid_file_w_tas_records_all_data ____________________

self = <sqlalchemy.engine.base.Connection object at 0x10f3e0280>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e23e0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f3e17e0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e23e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f3e17e0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.102915')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f3e17e0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.102915')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e0b20>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.102915')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e0b20>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f3e3c10>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e0b20>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f3e3bb0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_valid_file_w_tas_records_all_data(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamImport.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4550692768)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f3e1cc0>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bdaa100>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bdaa100>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bdaa100>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bdaa100>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bdaa100>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bdaa100>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f3e1cc0>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f3e1cc0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x10f3e1480>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f3e1cc0>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f3e2170>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f3e2170>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11aa2e030>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f3e2170>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f3e2170>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11aa2d4d0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e0280>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x10f3e0280>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e0280>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e0280>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11ae18be0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e23e0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e0280>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e23e0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e0280>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x10f3e17e0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e23e0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f3e0280>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e23e0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f3e17e0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f3e23e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f3e17e0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.102915')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f3e17e0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.102915')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e0b20>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.102915')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e0b20>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f3e3c10>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f3e0b20>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f3e3bb0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$KTtVbUqhmWqQ1MF1$45b64b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 102915)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_valid_file_w_tas_records_all_data(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                message = teamImport.team_csv_to_db(
                    retrieve_file_path("oneTeamTAStudent.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
    
                error_message = "team_csv_to_db() did not return the expected success message!"
                assert message == "Upload successful!", error_message
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() did not correctly create the valid test team!"
                assert teams.__len__() == 1, error_message
    
                teams = get_team_by_course_id(result["course_id"])
    
                team_users = get_team_users_by_team_id(teams[0].team_id)
    
                error_message = "teams_csv_to_db() did not correctly assign the test student to the test team!"
                assert team_users.__len__() == 2, error_message
    
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:52: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:49,104 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$KTtVbUqhmWqQ1MF1$45b64b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 102915)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$KTtVbUqhmWqQ1MF1$45b64b658214ee3022d06a340f72826a709c5ed65084cf9a2f56044c0982c077', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 102915)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
___________________ test_valid_file_wo_tas_records_all_data ____________________

self = <sqlalchemy.engine.base.Connection object at 0x10f4baef0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f4bbd30>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f4bbe80>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f4bbd30>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f4bbe80>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.446966')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f4bbe80>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.446966')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f4b9f60>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.446966')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f4b9f60>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f4bae90>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f4b9f60>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f4bafe0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_valid_file_wo_tas_records_all_data(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course(False)

Functions/test_files/test_teamImport.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = False, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4551583216)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f4ba620>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b4611c0>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b4611c0>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b4611c0>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b4611c0>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b4611c0>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b4611c0>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f4ba620>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f4ba620>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x10f4b9ff0>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f4ba620>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f4ba500>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f4ba500>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11aa0b5a0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f4ba500>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f4ba500>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11aa0a3b0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f4baef0>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x10f4baef0>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f4baef0>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f4baef0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11aef2860>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f4bbd30>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f4baef0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f4bbd30>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f4baef0>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x10f4bbe80>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f4bbd30>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f4baef0>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f4bbd30>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f4bbe80>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f4bbd30>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f4bbe80>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.446966')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f4bbe80>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.446966')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f4b9f60>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.446966')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f4b9f60>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f4bae90>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f4b9f60>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f4bafe0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$989l1KNqK4YPzxEO$5e5de4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 446966)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_valid_file_wo_tas_records_all_data(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course(False)
                message = teamImport.team_csv_to_db(
                    retrieve_file_path("oneTeamStudent.csv"),
                    result["admin_id"],
                    result["course_id"]
                )
    
                error_message = "team_csv_to_db() did not return the expected success message!"
                assert message == "Upload successful!", error_message
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() did not correctly assign the test team to the test course!"
                assert teams.__len__() == 1, error_message
    
                teams = get_team_by_course_id(result["course_id"])
                team_users = get_team_users_by_team_id(teams[0].team_id)
    
                error_message = "team_csv_to_db() did not correctly assign the test student to the test team!"
                assert team_users.__len__() == 1, error_message
    
                delete_all_teams_team_members(result["course_id"])
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:95: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:49,450 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$989l1KNqK4YPzxEO$5e5de4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 446966)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$989l1KNqK4YPzxEO$5e5de4fbfdbe7927abd00990912e009e6b6e7d749c081ec5261f8caaa415dd2a', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 446966)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
__________________________ test_wrong_file_type_error __________________________

self = <sqlalchemy.engine.base.Connection object at 0x11b619360>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b61bfa0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b61be20>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b61bfa0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b61be20>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.806682')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b61be20>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.806682')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b61a260>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.806682')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b61a260>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b619420>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b61a260>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b619330>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_wrong_file_type_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamImport.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4754349296)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b619c60>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae93400>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae93400>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae93400>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae93400>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae93400>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11ae93400>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b619c60>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b619c60>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b61a2f0>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b619c60>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b619f00>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b619f00>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11b884580>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b619f00>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b619f00>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11b886ff0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b619360>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b619360>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b619360>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b619360>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11b8f2020>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b61bfa0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b619360>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b61bfa0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b619360>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b61be20>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b61bfa0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b619360>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b61bfa0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b61be20>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b61bfa0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b61be20>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.806682')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b61be20>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.806682')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b61a260>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:49.806682')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b61a260>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b619420>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b61a260>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b619330>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$tO9D2QjsUv2X1Ju8$2772e22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 806682)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_wrong_file_type_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                try:
                    message = teamImport.team_csv_to_db(
                        retrieve_file_path(
                            "WrongFileType.pdf"
                        ),
                        result["admin_id"],
                        result["course_id"]
                    )
    
                except Exception as e:
                    assert isinstance(e, WrongExtension)
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should not assign a test team to a test course!"
                assert teams.__len__() == 0, error_message
    
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:129: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:49,810 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$tO9D2QjsUv2X1Ju8$2772e22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 806682)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$tO9D2QjsUv2X1Ju8$2772e22ace73584bf5e38e3538175a17c84f66fc52d7cffccffa1e6983860e3f', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 49, 806682)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
__________________________ test_file_not_found_error ___________________________

self = <sqlalchemy.engine.base.Connection object at 0x11aa85540>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aa87fa0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11aa854b0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aa87fa0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aa854b0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...70cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.204960')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aa854b0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...70cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.204960')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aa87520>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...70cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.204960')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aa87520>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11aa86170>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aa87520>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11aa876d0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_file_not_found_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamImport.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4742213984)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11aa85e70>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b1dc0c0>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b1dc0c0>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b1dc0c0>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b1dc0c0>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b1dc0c0>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b1dc0c0>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11aa85e70>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11aa85e70>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11aa86380>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11aa85e70>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11aa863e0>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11aa863e0>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11aadfd80>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11aa863e0>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11aa863e0>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11aadfe60>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aa85540>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11aa85540>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aa85540>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aa85540>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11b895240>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aa87fa0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aa85540>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aa87fa0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aa85540>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11aa854b0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aa87fa0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11aa85540>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aa87fa0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11aa854b0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11aa87fa0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aa854b0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...70cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.204960')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11aa854b0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...70cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.204960')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aa87520>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...70cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.204960')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aa87520>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11aa86170>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11aa87520>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11aa876d0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$w6tVpmgcowpVUequ$e902070cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 204960)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_file_not_found_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                try:
                    message = teamImport.team_csv_to_db(
                        retrieve_file_path(
                            "NonExistentFile.csv"
                        ),
                        result["admin_id"],
                        result["course_id"]
                    )
    
                except Exception as e:
                    assert isinstance(e, FileNotFoundError)
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should not assign a test team to a test course!"
                assert teams.__len__() == 0, error_message
    
                delete_one_admin_ta_student_course(result)
    
            except:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:163: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:50,207 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$w6tVpmgcowpVUequ$e902070cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 204960)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$w6tVpmgcowpVUequ$e902070cf9cb9ba37a139cdc57b796b588dc56f73226b3d77548c53ebe744bb0', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 204960)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
______________________ test_misformatting_TA_email_error _______________________

self = <sqlalchemy.engine.base.Connection object at 0x11b650a60>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b6535e0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b653370>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b6535e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b653370>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...21f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.561325')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b653370>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...21f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.561325')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b6515d0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...21f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.561325')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b6515d0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b653940>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b6515d0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b650dc0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_misformatting_TA_email_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamImport.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4754572288)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b651630>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f406740>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f406740>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f406740>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f406740>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f406740>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f406740>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b651630>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b651630>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b651960>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b651630>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b6532e0>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b6532e0>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11b8c1620>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b6532e0>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b6532e0>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11b8c38b0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b650a60>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b650a60>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b650a60>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b650a60>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11aa8a260>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b6535e0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b650a60>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b6535e0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b650a60>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b653370>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b6535e0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b650a60>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b6535e0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b653370>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b6535e0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b653370>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...21f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.561325')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b653370>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...21f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.561325')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b6515d0>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...21f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.561325')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b6515d0>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b653940>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b6515d0>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b650dc0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$t6T3SUya1WvNWpCT$2c04921f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 561325)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_misformatting_TA_email_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                try:
                    message = teamImport.team_csv_to_db(
                        retrieve_file_path(
                            "oneTeamMisformattedTAStudent.csv"
                        ),
                        result["admin_id"],
                        result["course_id"]
                    )
    
                except Exception as e:
                    assert isinstance(e, SuspectedMisformatting)
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should not assign a test team to a test course!"
                assert teams.__len__() == 0, error_message
    
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:200: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:50,564 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$t6T3SUya1WvNWpCT$2c04921f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 561325)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$t6T3SUya1WvNWpCT$2c04921f1cb521e27063fc3b22e9b52f65c0fba471a696ad8b26f7902065436a', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 561325)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
____________________ test_misformatting_student_email_error ____________________

self = <sqlalchemy.engine.base.Connection object at 0x11adac460>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11adae560>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11adaeaa0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11adae560>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11adaeaa0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...2ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.965135')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11adaeaa0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...2ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.965135')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11adac190>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...2ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.965135')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11adac190>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11adae6e0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11adac190>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11adade70>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_misformatting_student_email_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course(False)

Functions/test_files/test_teamImport.py:216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = False, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4745516640)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11adadc60>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f3ccf00>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f3ccf00>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f3ccf00>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f3ccf00>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f3ccf00>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x10f3ccf00>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11adadc60>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11adadc60>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11adaecb0>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11adadc60>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11adae980>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11adae980>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11a935000>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11adae980>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11adae980>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11a9359a0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11adac460>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11adac460>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11adac460>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11adac460>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11b8f6e60>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11adae560>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11adac460>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11adae560>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11adac460>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11adaeaa0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11adae560>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11adac460>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11adae560>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11adaeaa0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11adae560>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11adaeaa0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...2ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.965135')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11adaeaa0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...2ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.965135')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11adac190>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...2ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:50.965135')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11adac190>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11adae6e0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11adac190>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11adade70>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$fyRFnkAJZ4a4MY36$9d2352ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 965135)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_misformatting_student_email_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course(False)
                try:
                    message = teamImport.team_csv_to_db(
                        retrieve_file_path(
                            "oneTeamMisformattedStudent.csv"
                        ),
                        result["admin_id"],
                        result["course_id"]
                    )
    
                except Exception as e:
                    assert isinstance(e, SuspectedMisformatting)
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should not assign a test team to a test course!"
                assert teams.__len__() == 0, error_message
    
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:237: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:50,967 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$fyRFnkAJZ4a4MY36$9d2352ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 965135)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$fyRFnkAJZ4a4MY36$9d2352ef6a7127e45d885da05f8785a8a549c35c8aa0016cc648ab1435c2387d', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 50, 965135)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
________________________ test_users_do_not_exist_error _________________________

self = <sqlalchemy.engine.base.Connection object at 0x11bdfe020>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11bdfc970>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11bdfca60>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11bdfc970>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11bdfca60>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.335355')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11bdfca60>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.335355')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11bdff850>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.335355')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11bdff850>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11bdfe1d0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11bdff850>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11bdfe050>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_users_do_not_exist_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course()

Functions/test_files/test_teamImport.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4762630848)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11bdffc70>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b44ab00>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b44ab00>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b44ab00>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b44ab00>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b44ab00>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11b44ab00>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11bdffc70>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11bdffc70>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11bdff760>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11bdffc70>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11bdffb50>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11bdffb50>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11a9aa730>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11bdffb50>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11bdffb50>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11a9ab840>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11bdfe020>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11bdfe020>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11bdfe020>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11bdfe020>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11aad0280>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11bdfc970>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11bdfe020>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11bdfc970>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11bdfe020>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11bdfca60>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11bdfc970>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11bdfe020>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11bdfc970>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11bdfca60>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11bdfc970>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11bdfca60>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.335355')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11bdfca60>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.335355')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11bdff850>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.335355')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11bdff850>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11bdfe1d0>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11bdff850>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11bdfe050>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$EXuiZUNdGDaXqv51$ff519aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 51, 335355)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_users_do_not_exist_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course()
                try:
                    message = teamImport.team_csv_to_db(
                        retrieve_file_path(
                            "oneTeamNonExistingTAStudent.csv"
                        ),
                        result["admin_id"],
                        result["course_id"]
                    )
    
                except Exception as e:
                    assert isinstance(e, UserDoesNotExist)
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should not assign a test team to a test course!"
                assert teams.__len__() == 0, error_message
    
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:274: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:51,337 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$EXuiZUNdGDaXqv51$ff519aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 51, 335355)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$EXuiZUNdGDaXqv51$ff519aaadb6a64eecc0602c1d4fb5b3b1a335dcb003fa78aed4f8dd4df721de8', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 51, 335355)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
_________________________ test_ta_not_yet_added_error __________________________

self = <sqlalchemy.engine.base.Connection object at 0x11b8b7e80>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8b5810>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b8b6170>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8b5810>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b8b6170>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.723008')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b8b6170>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.723008')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8b5b40>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.723008')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8b5b40>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b8b7010>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8b5b40>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b8b7fd0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_ta_not_yet_added_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course(True, True)

Functions/test_files/test_teamImport.py:292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = True, unenroll_student = False

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4757091280)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b8b6230>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bc61f40>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bc61f40>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bc61f40>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bc61f40>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bc61f40>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11bc61f40>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b8b6230>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b8b6230>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x11b8b6890>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x11b8b6230>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b8b7910>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b8b7910>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11b4ab290>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b8b7910>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x11b8b7910>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11b4aadc0>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8b7e80>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x11b8b7e80>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8b7e80>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8b7e80>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11aa8ea40>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8b5810>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8b7e80>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8b5810>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8b7e80>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x11b8b6170>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8b5810>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x11b8b7e80>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8b5810>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x11b8b6170>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x11b8b5810>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b8b6170>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.723008')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x11b8b6170>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.723008')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8b5b40>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:51.723008')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8b5b40>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x11b8b7010>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x11b8b5b40>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x11b8b7fd0>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$UlBnpXVVh2htD3FJ$ad8b9cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 51, 723008)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_ta_not_yet_added_error(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course(True, True)
    
                try:
                    message = teamImport.team_csv_to_db(
                        retrieve_file_path(
                            "oneTeamTAStudent.csv"
                        ),
                        result["admin_id"],
                        result["course_id"]
                    )
                    assert False
                except Exception as e:
                    assert isinstance(e, TANotYetAddedToCourse)
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should not assign a test team to a test course!"
                assert teams.__len__() == 0, error_message
    
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:314: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:51,725 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$UlBnpXVVh2htD3FJ$ad8b9cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 51, 723008)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$UlBnpXVVh2htD3FJ$ad8b9cf5cc2bc4350567d1f276113aebf93f2db77d7bbcfb2b58726266d6c184', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 51, 723008)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
___________________ test_student_not_enrolled_in_this_course ___________________

self = <sqlalchemy.engine.base.Connection object at 0x10f5f4670>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f5f75b0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f5f4ee0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f5f75b0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f5f4ee0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...01aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:52.077656')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f5f4ee0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...01aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:52.077656')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f5f4790>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...01aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:52.077656')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f5f4790>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f5f4460>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f5f4790>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f5f5690>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       pymysql.err.IntegrityError: (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

The above exception was the direct cause of the following exception:

flask_app_mock = <Flask 'core'>

    def test_student_not_enrolled_in_this_course(flask_app_mock):
        with flask_app_mock.app_context():
            try:
>               result = create_one_admin_ta_student_course(True, False, True)

Functions/test_files/test_teamImport.py:333: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

use_tas = True, unenroll_ta = False, unenroll_student = True

    def create_one_admin_ta_student_course(use_tas=True, unenroll_ta=False, unenroll_student=False):
        teacher = template_user
        teacher["first_name"] = "Test Teacher"
        teacher["last_name"] = "1"
        teacher["email"] = f"testteacher@gmail.com"
        teacher["owner_id"] = 1
>       new_teacher = create_user(teacher)

Functions/test_files/PopulationFunctions.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
            return f(*args, *kwargs)
    
        except BaseException as e:
            logger.error(f"{e.__traceback__.tb_frame.f_code.co_filename} { e.__traceback__.tb_lineno} Error Type: {type(e).__name__} Message: {e}")
>           raise e

models/utility.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

args = ({'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'last_name': '1', ...},)
kwargs = {}

    def wrapper(*args, **kwargs):
        try:
>           return f(*args, *kwargs)

models/utility.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

user_data = <User (transient 4552881776)>, owner_email = None

    @error_log
    def create_user(user_data, owner_email=None):
        if "password" in user_data:
            password = user_data["password"]
            has_set_password = True # for demo users, avoid requirement to choose new password
        else:
            password = generate_random_password(6)
            send_new_user_email(user_data["email"], password)
    
            has_set_password = False
    
        password_hash = generate_password_hash(password)
        last_update = datetime.now()
    
        user_data = User(
            first_name=user_data["first_name"],
            last_name=user_data["last_name"],
            email=user_data["email"].lower().strip(),
            password=password_hash,
            lms_id=user_data["lms_id"],
            consent=user_data["consent"],
            owner_id=user_data["owner_id"],
            is_admin="role_id" in user_data.keys() and user_data["role_id"] in [1,2,3],
            has_set_password=has_set_password,
            reset_code=None,
            last_update=last_update,
        )
    
        db.session.add(user_data)
    
>       db.session.commit()

models/user.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.scoping.scoped_session object at 0x109300f10>

    def commit(self) -> None:
        r"""Flush pending changes and commit the current transaction.
    
        .. container:: class_bases
    
            Proxied for the :class:`_orm.Session` class on
            behalf of the :class:`_orm.scoping.scoped_session` class.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
    
        """  # noqa: E501
    
>       return self._proxied.commit()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/scoping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f5f5960>

    def commit(self) -> None:
        """Flush pending changes and commit the current transaction.
    
        When the COMMIT operation is complete, all objects are fully
        :term:`expired`, erasing their internal contents, which will be
        automatically re-loaded when the objects are next accessed. In the
        interim, these objects are in an expired state and will not function if
        they are :term:`detached` from the :class:`.Session`. Additionally,
        this re-load operation is not supported when using asyncio-oriented
        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used
        to disable this behavior.
    
        When there is no transaction in place for the :class:`.Session`,
        indicating that no operations were invoked on this :class:`.Session`
        since the previous call to :meth:`.Session.commit`, the method will
        begin and commit an internal-only "logical" transaction, that does not
        normally affect the database unless pending flush changes were
        detected, but will still invoke event handlers and object expiration
        rules.
    
        The outermost database transaction is committed unconditionally,
        automatically releasing any SAVEPOINTs in effect.
    
        .. seealso::
    
            :ref:`session_committing`
    
            :ref:`unitofwork_transaction`
    
            :ref:`asyncio_orm_avoid_lazyloads`
    
        """
        trans = self._transaction
        if trans is None:
            trans = self._autobegin_t()
    
>       trans.commit(_to_root=True)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11a88b700>
_to_root = True

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction.commit at 0x108f1fb50>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11a88b700>
arg = (), kw = {'_to_root': True}
current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <_StateChangeStates.ANY: 1>, existing_fn = None
expect_state = <SessionTransactionState.CLOSED: 5>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11a88b700>
_to_root = True

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE, SessionTransactionState.PREPARED),
        SessionTransactionState.CLOSED,
    )
    def commit(self, _to_root: bool = False) -> None:
        if self._state is not SessionTransactionState.PREPARED:
            with self._expect_state(SessionTransactionState.PREPARED):
>               self._prepare_impl()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11a88b700>

>   ???

<string>:2: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fn = <function SessionTransaction._prepare_impl at 0x108f1f9a0>
self = <sqlalchemy.orm.session.SessionTransaction object at 0x11a88b700>
arg = (), kw = {}, current_state = <SessionTransactionState.ACTIVE: 1>
next_state = <SessionTransactionState.PREPARED: 2>
existing_fn = <function SessionTransaction.commit at 0x108f1fb50>
expect_state = <SessionTransactionState.PREPARED: 2>

    @util.decorator
    def _go(fn: _F, self: Any, *arg: Any, **kw: Any) -> Any:
    
        current_state = self._state
    
        if (
            has_prerequisite_states
            and current_state not in prerequisite_state_collection
        ):
            self._raise_for_prerequisite_state(fn.__name__, current_state)
    
        next_state = self._next_state
        existing_fn = self._current_fn
        expect_state = moves_to if expect_state_change else current_state
    
        if (
            # destination states are restricted
            next_state is not _StateChangeStates.ANY
            # method seeks to change state
            and expect_state_change
            # destination state incorrect
            and next_state is not expect_state
        ):
            if existing_fn and next_state in (
                _StateChangeStates.NO_CHANGE,
                _StateChangeStates.CHANGE_IN_PROGRESS,
            ):
                raise sa_exc.IllegalStateChangeError(
                    f"Method '{fn.__name__}()' can't be called here; "
                    f"method '{existing_fn.__name__}()' is already "
                    f"in progress and this would cause an unexpected "
                    f"state change to {moves_to!r}"
                )
            else:
                raise sa_exc.IllegalStateChangeError(
                    f"Cant run operation '{fn.__name__}()' here; "
                    f"will move to state {moves_to!r} where we are "
                    f"expecting {next_state!r}"
                )
    
        self._current_fn = fn
        self._next_state = _StateChangeStates.CHANGE_IN_PROGRESS
        try:
>           ret_value = fn(self, *arg, **kw)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/state_changes.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.SessionTransaction object at 0x11a88b700>

    @_StateChange.declare_states(
        (SessionTransactionState.ACTIVE,), SessionTransactionState.PREPARED
    )
    def _prepare_impl(self) -> None:
    
        if self._parent is None or self.nested:
            self.session.dispatch.before_commit(self.session)
    
        stx = self.session._transaction
        assert stx is not None
        if stx is not self:
            for subtransaction in stx._iterate_self_and_parents(upto=self):
                subtransaction.commit()
    
        if not self.session._flushing:
            for _flush_guard in range(100):
                if self.session._is_clean():
                    break
>               self.session.flush()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:1196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f5f5960>, objects = None

    def flush(self, objects: Optional[Sequence[Any]] = None) -> None:
        """Flush all the object changes to the database.
    
        Writes out all pending object creations, deletions and modifications
        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are
        automatically ordered by the Session's unit of work dependency
        solver.
    
        Database operations will be issued in the current transactional
        context and do not affect the state of the transaction, unless an
        error occurs, in which case the entire transaction is rolled back.
        You may flush() as often as you like within a transaction to move
        changes from Python to the database's transaction buffer.
    
        :param objects: Optional; restricts the flush operation to operate
          only on elements that are in the given collection.
    
          This feature is for an extremely narrow set of use cases where
          particular objects may need to be operated upon before the
          full flush() occurs.  It is not intended for general use.
    
        """
    
        if self._flushing:
            raise sa_exc.InvalidRequestError("Session is already flushing")
    
        if self._is_clean():
            return
        try:
            self._flushing = True
>           self._flush(objects)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f5f5960>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
                flush_context.execute()
            finally:
                self._warn_on_events = False
    
            self.dispatch.after_flush(self, flush_context)
    
            flush_context.finalize_flush_changes()
    
            if not objects and self.identity_map._modified:
                len_ = len(self.identity_map._modified)
    
                statelib.InstanceState._commit_all_states(
                    [
                        (state, state.dict)
                        for state in self.identity_map._modified
                    ],
                    instance_dict=self.identity_map,
                )
                util.warn(
                    "Attribute history events accumulated on %d "
                    "previously clean instances "
                    "within inner-flush event handlers have been "
                    "reset, and will not result in database updates. "
                    "Consider using set_committed_value() within "
                    "inner-flush event handlers to avoid this warning." % len_
                )
    
            # useful assertions:
            # if not objects:
            #    assert not self.identity_map._modified
            # else:
            #    assert self.identity_map._modified == \
            #            self.identity_map._modified.difference(objects)
    
            self.dispatch.after_flush_postexec(self, flush_context)
    
            transaction.commit()
    
        except:
>           with util.safe_reraise():

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4290: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.util.langhelpers.safe_reraise object at 0x10f5f7130>
type_ = None, value = None, traceback = None

    def __exit__(
        self,
        type_: Optional[Type[BaseException]],
        value: Optional[BaseException],
        traceback: Optional[types.TracebackType],
    ) -> NoReturn:
        assert self._exc_info is not None
        # see #2703 for notes
        if type_ is None:
            exc_type, exc_value, exc_tb = self._exc_info
            assert exc_value is not None
            self._exc_info = None  # remove potential circular references
>           raise exc_value.with_traceback(exc_tb)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/util/langhelpers.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.session.Session object at 0x10f5f5960>, objects = None

    def _flush(self, objects: Optional[Sequence[object]] = None) -> None:
    
        dirty = self._dirty_states
        if not dirty and not self._deleted and not self._new:
            self.identity_map._modified.clear()
            return
    
        flush_context = UOWTransaction(self)
    
        if self.dispatch.before_flush:
            self.dispatch.before_flush(self, flush_context, objects)
            # re-establish "dirty states" in case the listeners
            # added
            dirty = self._dirty_states
    
        deleted = set(self._deleted)
        new = set(self._new)
    
        dirty = set(dirty).difference(deleted)
    
        # create the set of all objects we want to operate upon
        if objects:
            # specific list passed in
            objset = set()
            for o in objects:
                try:
                    state = attributes.instance_state(o)
    
                except exc.NO_STATE as err:
                    raise exc.UnmappedInstanceError(o) from err
                objset.add(state)
        else:
            objset = None
    
        # store objects whose fate has been decided
        processed = set()
    
        # put all saves/updates into the flush context.  detect top-level
        # orphans and throw them into deleted.
        if objset:
            proc = new.union(dirty).intersection(objset).difference(deleted)
        else:
            proc = new.union(dirty).difference(deleted)
    
        for state in proc:
            is_orphan = _state_mapper(state)._is_orphan(state)
    
            is_persistent_orphan = is_orphan and state.has_identity
    
            if (
                is_orphan
                and not is_persistent_orphan
                and state._orphaned_outside_of_session
            ):
                self._expunge_states([state])
            else:
                _reg = flush_context.register_object(
                    state, isdelete=is_persistent_orphan
                )
                assert _reg, "Failed to add object to the flush context!"
                processed.add(state)
    
        # put all remaining deletes into the flush context.
        if objset:
            proc = deleted.intersection(objset).difference(processed)
        else:
            proc = deleted.difference(processed)
        for state in proc:
            _reg = flush_context.register_object(state, isdelete=True)
            assert _reg, "Failed to add object to the flush context!"
    
        if not flush_context.has_work:
            return
    
        flush_context.transaction = transaction = self._autobegin_t()._begin()
        try:
            self._warn_on_events = True
            try:
>               flush_context.execute()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/session.py:4251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f5f5510>

    def execute(self) -> None:
        postsort_actions = self._generate_actions()
    
        postsort_actions = sorted(
            postsort_actions,
            key=lambda item: item.sort_key,
        )
        # sort = topological.sort(self.dependencies, postsort_actions)
        # print "--------------"
        # print "\ndependencies:", self.dependencies
        # print "\ncycles:", self.cycles
        # print "\nsort:", list(sort)
        # print "\nCOUNT OF POSTSORT ACTIONS", len(postsort_actions)
    
        # execute
        if self.cycles:
            for subset in topological.sort_as_subsets(
                self.dependencies, postsort_actions
            ):
                set_ = set(subset)
                while set_:
                    n = set_.pop()
                    n.execute_aggregate(self, set_)
        else:
            for rec in topological.sort(self.dependencies, postsort_actions):
>               rec.execute(self)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SaveUpdateAll(Mapper[User(User)])
uow = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f5f5510>

    @util.preload_module("sqlalchemy.orm.persistence")
    def execute(self, uow):
>       util.preloaded.orm_persistence.save_obj(
            self.mapper,
            uow.states_for_mapper_hierarchy(self.mapper, False, False),
            uow,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/unitofwork.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
states = <generator object UOWTransaction.states_for_mapper_hierarchy at 0x11b7b8cf0>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f5f5510>
single = False

    def save_obj(base_mapper, states, uowtransaction, single=False):
        """Issue ``INSERT`` and/or ``UPDATE`` statements for a list
        of objects.
    
        This is called within the context of a UOWTransaction during a
        flush operation, given a list of states to be flushed.  The
        base mapper in an inheritance hierarchy handles the inserts/
        updates for all descendant mappers.
    
        """
    
        # if batch=false, call _save_obj separately for each object
        if not single and not base_mapper.batch:
            for state in _sort_states(base_mapper, states):
                save_obj(base_mapper, [state], uowtransaction, single=True)
            return
    
        states_to_update = []
        states_to_insert = []
    
        for (
            state,
            dict_,
            mapper,
            connection,
            has_identity,
            row_switch,
            update_version_id,
        ) in _organize_states_for_save(base_mapper, states, uowtransaction):
            if has_identity or row_switch:
                states_to_update.append(
                    (state, dict_, mapper, connection, update_version_id)
                )
            else:
                states_to_insert.append((state, dict_, mapper, connection))
    
        for table, mapper in base_mapper._sorted_tables.items():
            if table not in mapper._pks_by_table:
                continue
            insert = _collect_insert_commands(table, states_to_insert)
    
            update = _collect_update_commands(
                uowtransaction, table, states_to_update
            )
    
            _emit_update_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                update,
            )
    
>           _emit_insert_statements(
                base_mapper,
                uowtransaction,
                mapper,
                table,
                insert,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

base_mapper = <Mapper at 0x1097861d0; User>
uowtransaction = <sqlalchemy.orm.unitofwork.UOWTransaction object at 0x10f5f5510>
mapper = <Mapper at 0x1097861d0; User>
table = Table('User', MetaData(), Column('user_id', Integer(), table=<User>, primary_key=True, nullable=False), Column('first_...', Boolean(), table=<User>, nullable=False), Column('last_update', DateTime(timezone=True), table=<User>), schema=None)
insert = <generator object _collect_insert_commands at 0x11b7b9930>

    def _emit_insert_statements(
        base_mapper,
        uowtransaction,
        mapper,
        table,
        insert,
        *,
        bookkeeping=True,
        use_orm_insert_stmt=None,
        execution_options=None,
    ):
        """Emit INSERT statements corresponding to value lists collected
        by _collect_insert_commands()."""
    
        if use_orm_insert_stmt is not None:
            cached_stmt = use_orm_insert_stmt
            exec_opt = util.EMPTY_DICT
    
            # if a user query with RETURNING was passed, we definitely need
            # to use RETURNING.
            returning_is_required_anyway = bool(use_orm_insert_stmt._returning)
            deterministic_results_reqd = (
                returning_is_required_anyway
                and use_orm_insert_stmt._sort_by_parameter_order
            ) or bookkeeping
        else:
            returning_is_required_anyway = False
            deterministic_results_reqd = bookkeeping
            cached_stmt = base_mapper._memo(("insert", table), table.insert)
            exec_opt = {"compiled_cache": base_mapper._compiled_cache}
    
        if execution_options:
            execution_options = util.EMPTY_DICT.merge_with(
                exec_opt, execution_options
            )
        else:
            execution_options = exec_opt
    
        return_result = None
    
        for (
            (connection, _, hasvalue, has_all_pks, has_all_defaults),
            records,
        ) in groupby(
            insert,
            lambda rec: (
                rec[4],  # connection
                set(rec[2]),  # parameter keys
                bool(rec[5]),  # whether we have "value" parameters
                rec[6],
                rec[7],
            ),
        ):
    
            statement = cached_stmt
    
            if use_orm_insert_stmt is not None:
                statement = statement._annotate(
                    {
                        "_emit_insert_table": table,
                        "_emit_insert_mapper": mapper,
                    }
                )
    
            if (
                (
                    not bookkeeping
                    or (
                        has_all_defaults
                        or not base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                        or not table.implicit_returning
                        or not connection.dialect.insert_returning
                    )
                )
                and not returning_is_required_anyway
                and has_all_pks
                and not hasvalue
            ):
    
                # the "we don't need newly generated values back" section.
                # here we have all the PKs, all the defaults or we don't want
                # to fetch them, or the dialect doesn't support RETURNING at all
                # so we have to post-fetch / use lastrowid anyway.
                records = list(records)
                multiparams = [rec[2] for rec in records]
    
                result = connection.execute(
                    statement, multiparams, execution_options=execution_options
                )
                if bookkeeping:
                    for (
                        (
                            state,
                            state_dict,
                            params,
                            mapper_rec,
                            conn,
                            value_params,
                            has_all_pks,
                            has_all_defaults,
                        ),
                        last_inserted_params,
                    ) in zip(records, result.context.compiled_parameters):
                        if state:
                            _postfetch(
                                mapper_rec,
                                uowtransaction,
                                table,
                                state,
                                state_dict,
                                result,
                                last_inserted_params,
                                value_params,
                                False,
                                result.returned_defaults
                                if not result.context.executemany
                                else None,
                            )
                        else:
                            _postfetch_bulk_save(mapper_rec, state_dict, table)
    
            else:
                # here, we need defaults and/or pk values back or we otherwise
                # know that we are using RETURNING in any case
    
                records = list(records)
    
                if returning_is_required_anyway or (
                    not hasvalue and len(records) > 1
                ):
                    if (
                        deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning_sort_by_parameter_order  # noqa: E501
                    ) or (
                        not deterministic_results_reqd
                        and connection.dialect.insert_executemany_returning
                    ):
                        do_executemany = True
                    elif returning_is_required_anyway:
                        if deterministic_results_reqd:
                            dt = " with RETURNING and sort by parameter order"
                        else:
                            dt = " with RETURNING"
                        raise sa_exc.InvalidRequestError(
                            f"Can't use explicit RETURNING for bulk INSERT "
                            f"operation with "
                            f"{connection.dialect.dialect_description} backend; "
                            f"executemany{dt} is not enabled for this dialect."
                        )
                    else:
                        do_executemany = False
                else:
                    do_executemany = False
    
                if use_orm_insert_stmt is None:
                    if (
                        not has_all_defaults
                        and base_mapper._prefer_eager_defaults(
                            connection.dialect, table
                        )
                    ):
                        statement = statement.return_defaults(
                            *mapper._server_default_cols[table],
                            sort_by_parameter_order=bookkeeping,
                        )
    
                if mapper.version_id_col is not None:
                    statement = statement.return_defaults(
                        mapper.version_id_col,
                        sort_by_parameter_order=bookkeeping,
                    )
                elif do_executemany:
                    statement = statement.return_defaults(
                        *table.primary_key, sort_by_parameter_order=bookkeeping
                    )
    
                if do_executemany:
                    multiparams = [rec[2] for rec in records]
    
                    result = connection.execute(
                        statement, multiparams, execution_options=execution_options
                    )
    
                    if use_orm_insert_stmt is not None:
                        if return_result is None:
                            return_result = result
                        else:
                            return_result = return_result.splice_vertically(result)
    
                    if bookkeeping:
                        for (
                            (
                                state,
                                state_dict,
                                params,
                                mapper_rec,
                                conn,
                                value_params,
                                has_all_pks,
                                has_all_defaults,
                            ),
                            last_inserted_params,
                            inserted_primary_key,
                            returned_defaults,
                        ) in zip_longest(
                            records,
                            result.context.compiled_parameters,
                            result.inserted_primary_key_rows,
                            result.returned_defaults_rows or (),
                        ):
                            if inserted_primary_key is None:
                                # this is a real problem and means that we didn't
                                # get back as many PK rows.  we can't continue
                                # since this indicates PK rows were missing, which
                                # means we likely mis-populated records starting
                                # at that point with incorrectly matched PK
                                # values.
                                raise orm_exc.FlushError(
                                    "Multi-row INSERT statement for %s did not "
                                    "produce "
                                    "the correct number of INSERTed rows for "
                                    "RETURNING.  Ensure there are no triggers or "
                                    "special driver issues preventing INSERT from "
                                    "functioning properly." % mapper_rec
                                )
    
                            for pk, col in zip(
                                inserted_primary_key,
                                mapper._pks_by_table[table],
                            ):
                                prop = mapper_rec._columntoproperty[col]
                                if state_dict.get(prop.key) is None:
                                    state_dict[prop.key] = pk
    
                            if state:
                                _postfetch(
                                    mapper_rec,
                                    uowtransaction,
                                    table,
                                    state,
                                    state_dict,
                                    result,
                                    last_inserted_params,
                                    value_params,
                                    False,
                                    returned_defaults,
                                )
                            else:
                                _postfetch_bulk_save(mapper_rec, state_dict, table)
                else:
                    assert not returning_is_required_anyway
    
                    for (
                        state,
                        state_dict,
                        params,
                        mapper_rec,
                        connection,
                        value_params,
                        has_all_pks,
                        has_all_defaults,
                    ) in records:
                        if value_params:
                            result = connection.execute(
                                statement.values(value_params),
                                params,
                                execution_options=execution_options,
                            )
                        else:
>                           result = connection.execute(
                                statement,
                                params,
                                execution_options=execution_options,
                            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/orm/persistence.py:1223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f5f4670>
statement = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}

    def execute(
        self,
        statement: Executable,
        parameters: Optional[_CoreAnyExecuteParams] = None,
        *,
        execution_options: Optional[CoreExecuteOptionsParameter] = None,
    ) -> CursorResult[Any]:
        r"""Executes a SQL statement construct and returns a
        :class:`_engine.CursorResult`.
    
        :param statement: The statement to be executed.  This is always
         an object that is in both the :class:`_expression.ClauseElement` and
         :class:`_expression.Executable` hierarchies, including:
    
         * :class:`_expression.Select`
         * :class:`_expression.Insert`, :class:`_expression.Update`,
           :class:`_expression.Delete`
         * :class:`_expression.TextClause` and
           :class:`_expression.TextualSelect`
         * :class:`_schema.DDL` and objects which inherit from
           :class:`_schema.ExecutableDDLElement`
    
        :param parameters: parameters which will be bound into the statement.
         This may be either a dictionary of parameter names to values,
         or a mutable sequence (e.g. a list) of dictionaries.  When a
         list of dictionaries is passed, the underlying statement execution
         will make use of the DBAPI ``cursor.executemany()`` method.
         When a single dictionary is passed, the DBAPI ``cursor.execute()``
         method will be used.
    
        :param execution_options: optional dictionary of execution options,
         which will be associated with the statement execution.  This
         dictionary can provide a subset of the options that are accepted
         by :meth:`_engine.Connection.execution_options`.
    
        :return: a :class:`_engine.Result` object.
    
        """
        distilled_parameters = _distill_params_20(parameters)
        try:
            meth = statement._execute_on_connection
        except AttributeError as err:
            raise exc.ObjectNotExecutableError(statement) from err
        else:
>           return meth(
                self,
                distilled_parameters,
                execution_options or NO_OPTIONS,
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1413: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
connection = <sqlalchemy.engine.base.Connection object at 0x10f5f4670>
distilled_params = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = {'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>}

    def _execute_on_connection(
        self,
        connection: Connection,
        distilled_params: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> Result[Any]:
        if self.supports_execution:
            if TYPE_CHECKING:
                assert isinstance(self, Executable)
>           return connection._execute_clauseelement(
                self, distilled_params, execution_options
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/sql/elements.py:483: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f5f4670>
elem = <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>
distilled_parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})

    def _execute_clauseelement(
        self,
        elem: Executable,
        distilled_parameters: _CoreMultiExecuteParams,
        execution_options: CoreExecuteOptionsParameter,
    ) -> CursorResult[Any]:
        """Execute a sql.ClauseElement object."""
    
        execution_options = elem._execution_options.merge_with(
            self._execution_options, execution_options
        )
    
        has_events = self._has_events or self.engine._has_events
        if has_events:
            (
                elem,
                distilled_parameters,
                event_multiparams,
                event_params,
            ) = self._invoke_before_exec_event(
                elem, distilled_parameters, execution_options
            )
    
        if distilled_parameters:
            # ensure we don't retain a link to the view object for keys()
            # which links to the values, which we don't want to cache
            keys = sorted(distilled_parameters[0])
            for_executemany = len(distilled_parameters) > 1
        else:
            keys = []
            for_executemany = False
    
        dialect = self.dialect
    
        schema_translate_map = execution_options.get(
            "schema_translate_map", None
        )
    
        compiled_cache: Optional[CompiledCacheType] = execution_options.get(
            "compiled_cache", self.engine._compiled_cache
        )
    
        compiled_sql, extracted_params, cache_hit = elem._compile_w_cache(
            dialect=dialect,
            compiled_cache=compiled_cache,
            column_keys=keys,
            for_executemany=for_executemany,
            schema_translate_map=schema_translate_map,
            linting=self.dialect.compiler_linting | compiler.WARN_LINTING,
        )
>       ret = self._execute_context(
            dialect,
            dialect.execution_ctx_cls._init_compiled,
            compiled_sql,
            distilled_parameters,
            execution_options,
            compiled_sql,
            distilled_parameters,
            elem,
            extracted_params,
            cache_hit=cache_hit,
        )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1637: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f5f4670>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
constructor = <bound method DefaultExecutionContext._init_compiled of <class 'sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb'>>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': True, ...}]
execution_options = immutabledict({'compiled_cache': <sqlalchemy.util._collections.LRUCache object at 0x10f0f3ab0>})
args = (<sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>, [{'consent': None, 'email': 'testtea..., 'first_name': 'Test Teacher', 'has_set_password': True, ...}], <sqlalchemy.sql.dml.Insert object at 0x10f106bf0>, [])
kw = {'cache_hit': <CacheStats.CACHE_HIT: 0>}, yp = None
conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x11a93bd60>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f5f75b0>

    def _execute_context(
        self,
        dialect: Dialect,
        constructor: Callable[..., ExecutionContext],
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
        execution_options: _ExecuteOptions,
        *args: Any,
        **kw: Any,
    ) -> CursorResult[Any]:
        """Create an :class:`.ExecutionContext` and execute, returning
        a :class:`_engine.CursorResult`."""
    
        if execution_options:
            yp = execution_options.get("yield_per", None)
            if yp:
                execution_options = execution_options.union(
                    {"stream_results": True, "max_row_buffer": yp}
                )
        try:
            conn = self._dbapi_connection
            if conn is None:
                conn = self._revalidate_connection()
    
            context = constructor(
                dialect, self, conn, execution_options, *args, **kw
            )
        except (exc.PendingRollbackError, exc.ResourceClosedError):
            raise
        except BaseException as e:
            self._handle_dbapi_exception(
                e, str(statement), parameters, None, None
            )
    
        if (
            self._transaction
            and not self._transaction.is_active
            or (
                self._nested_transaction
                and not self._nested_transaction.is_active
            )
        ):
            self._invalid_transaction()
    
        elif self._trans_context_manager:
            TransactionalContext._trans_ctx_check(self)
    
        if self._transaction is None:
            self._autobegin()
    
        context.pre_exec()
    
        if context.execute_style is ExecuteStyle.INSERTMANYVALUES:
            return self._exec_insertmany_context(
                dialect,
                context,
            )
        else:
>           return self._exec_single_context(
                dialect, context, statement, parameters
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1841: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f5f4670>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f5f75b0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )
    
            if self._has_events or self.engine._has_events:
                self.dispatch.after_cursor_execute(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
            context.post_exec()
    
            result = context._setup_result_proxy()
    
        except BaseException as e:
>           self._handle_dbapi_exception(
                e, str_statement, effective_parameters, cursor, context
            )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1982: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f5f4670>
e = IntegrityError(1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
cursor = <pymysql.cursors.Cursor object at 0x10f5f4ee0>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f5f75b0>
is_sub_exec = False

    def _handle_dbapi_exception(
        self,
        e: BaseException,
        statement: Optional[str],
        parameters: Optional[_AnyExecuteParams],
        cursor: Optional[DBAPICursor],
        context: Optional[ExecutionContext],
        is_sub_exec: bool = False,
    ) -> NoReturn:
        exc_info = sys.exc_info()
    
        is_exit_exception = util.is_exit_exception(e)
    
        if not self._is_disconnect:
            self._is_disconnect = (
                isinstance(e, self.dialect.loaded_dbapi.Error)
                and not self.closed
                and self.dialect.is_disconnect(
                    e,
                    self._dbapi_connection if not self.invalidated else None,
                    cursor,
                )
            ) or (is_exit_exception and not self.closed)
    
        invalidate_pool_on_disconnect = not is_exit_exception
    
        ismulti: bool = (
            not is_sub_exec and context.executemany
            if context is not None
            else False
        )
        if self._reentrant_error:
            raise exc.DBAPIError.instance(
                statement,
                parameters,
                e,
                self.dialect.loaded_dbapi.Error,
                hide_parameters=self.engine.hide_parameters,
                dialect=self.dialect,
                ismulti=ismulti,
            ).with_traceback(exc_info[2]) from e
        self._reentrant_error = True
        try:
            # non-DBAPI error - if we already got a context,
            # or there's no string statement, don't wrap it
            should_wrap = isinstance(e, self.dialect.loaded_dbapi.Error) or (
                statement is not None
                and context is None
                and not is_exit_exception
            )
    
            if should_wrap:
                sqlalchemy_exception = exc.DBAPIError.instance(
                    statement,
                    parameters,
                    cast(Exception, e),
                    self.dialect.loaded_dbapi.Error,
                    hide_parameters=self.engine.hide_parameters,
                    connection_invalidated=self._is_disconnect,
                    dialect=self.dialect,
                    ismulti=ismulti,
                )
            else:
                sqlalchemy_exception = None
    
            newraise = None
    
            if (self.dialect._has_events) and not self._execution_options.get(
                "skip_user_error_events", False
            ):
                ctx = ExceptionContextImpl(
                    e,
                    sqlalchemy_exception,
                    self.engine,
                    self.dialect,
                    self,
                    cursor,
                    statement,
                    parameters,
                    context,
                    self._is_disconnect,
                    invalidate_pool_on_disconnect,
                    False,
                )
    
                for fn in self.dialect.dispatch.handle_error:
                    try:
                        # handler returns an exception;
                        # call next handler in a chain
                        per_fn = fn(ctx)
                        if per_fn is not None:
                            ctx.chained_exception = newraise = per_fn
                    except Exception as _raised:
                        # handler raises an exception - stop processing
                        newraise = _raised
                        break
    
                if self._is_disconnect != ctx.is_disconnect:
                    self._is_disconnect = ctx.is_disconnect
                    if sqlalchemy_exception:
                        sqlalchemy_exception.connection_invalidated = (
                            ctx.is_disconnect
                        )
    
                # set up potentially user-defined value for
                # invalidate pool.
                invalidate_pool_on_disconnect = (
                    ctx.invalidate_pool_on_disconnect
                )
    
            if should_wrap and context:
                context.handle_dbapi_exception(e)
    
            if not self._is_disconnect:
                if cursor:
                    self._safe_close_cursor(cursor)
                # "autorollback" was mostly relevant in 1.x series.
                # It's very unlikely to reach here, as the connection
                # does autobegin so when we are here, we are usually
                # in an explicit / semi-explicit transaction.
                # however we have a test which manufactures this
                # scenario in any case using an event handler.
                # test/engine/test_execute.py-> test_actual_autorollback
                if not self.in_transaction():
                    self._rollback_impl()
    
            if newraise:
                raise newraise.with_traceback(exc_info[2]) from e
            elif should_wrap:
                assert sqlalchemy_exception is not None
>               raise sqlalchemy_exception.with_traceback(exc_info[2]) from e

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2339: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.engine.base.Connection object at 0x10f5f4670>
dialect = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f5f75b0>
statement = <sqlalchemy.dialects.mysql.mysqldb.MySQLCompiler_mysqldb object at 0x10f0e38b0>
parameters = [{'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
    
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1963: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlalchemy.dialects.mysql.pymysql.MySQLDialect_pymysql object at 0x109301630>
cursor = <pymysql.cursors.Cursor object at 0x10f5f4ee0>
statement = 'INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...assword)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)'
parameters = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}
context = <sqlalchemy.dialects.mysql.mysqldb.MySQLExecutionContext_mysqldb object at 0x10f5f75b0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/sqlalchemy/engine/default.py:920: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f5f4ee0>
query = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...01aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:52.077656')"
args = {'consent': None, 'email': 'testteacher@gmail.com', 'first_name': 'Test Teacher', 'has_set_password': 1, ...}

    def execute(self, query, args=None):
        """Execute a query.
    
        :param query: Query to execute.
        :type query: str
    
        :param args: Parameters used with query. (optional)
        :type args: tuple, list or dict
    
        :return: Number of affected rows.
        :rtype: int
    
        If args is a list or tuple, %s can be used as a placeholder in the query.
        If args is a dict, %(name)s can be used as a placeholder in the query.
        """
        while self.nextset():
            pass
    
        query = self.mogrify(query, args)
    
>       result = self._query(query)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.cursors.Cursor object at 0x10f5f4ee0>
q = "INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, ...01aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:52.077656')"

    def _query(self, q):
        conn = self._get_db()
        self._clear_result()
>       conn.query(q)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/cursors.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f5f4790>
sql = b"INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code,...01aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', NULL, NULL, 1, 1, NULL, 0, '2025-03-04 14:11:52.077656')"
unbuffered = False

    def query(self, sql, unbuffered=False):
        # if DEBUG:
        #     print("DEBUG: sending query:", sql)
        if isinstance(sql, str):
            sql = sql.encode(self.encoding, "surrogateescape")
        self._execute_command(COMMAND.COM_QUERY, sql)
>       self._affected_rows = self._read_query_result(unbuffered=unbuffered)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f5f4790>
unbuffered = False

    def _read_query_result(self, unbuffered=False):
        self._result = None
        if unbuffered:
            try:
                result = MySQLResult(self)
                result.init_unbuffered_query()
            except:
                result.unbuffered_active = False
                result.connection = None
                raise
        else:
            result = MySQLResult(self)
>           result.read()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:779: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.MySQLResult object at 0x10f5f4460>

    def read(self):
        try:
>           first_packet = self.connection._read_packet()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:1157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.connections.Connection object at 0x10f5f4790>
packet_type = <class 'pymysql.protocol.MysqlPacket'>

    def _read_packet(self, packet_type=MysqlPacket):
        """Read an entire "mysql packet" in its entirety from the network
        and return a MysqlPacket type that represents the results.
    
        :raise OperationalError: If the connection to the MySQL server is lost.
        :raise InternalError: If the packet sequence number is wrong.
        """
        buff = bytearray()
        while True:
            packet_header = self._read_bytes(4)
            # if DEBUG: dump_packet(packet_header)
    
            btrl, btrh, packet_number = struct.unpack("<HBB", packet_header)
            bytes_to_read = btrl + (btrh << 16)
            if packet_number != self._next_seq_id:
                self._force_close()
                if packet_number == 0:
                    # MariaDB sends error packet with seqno==0 when shutdown
                    raise err.OperationalError(
                        CR.CR_SERVER_LOST,
                        "Lost connection to MySQL server during query",
                    )
                raise err.InternalError(
                    "Packet sequence number wrong - got %d expected %d"
                    % (packet_number, self._next_seq_id)
                )
            self._next_seq_id = (self._next_seq_id + 1) % 256
    
            recv_data = self._read_bytes(bytes_to_read)
            if DEBUG:
                dump_packet(recv_data)
            buff += recv_data
            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html
            if bytes_to_read == 0xFFFFFF:
                continue
            if bytes_to_read < MAX_PACKET_LEN:
                break
    
        packet = packet_type(bytes(buff), self.encoding)
        if packet.is_error_packet():
            if self._result is not None and self._result.unbuffered_active is True:
                self._result.unbuffered_active = False
>           packet.raise_for_error()

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/connections.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <pymysql.protocol.MysqlPacket object at 0x10f5f5690>

    def raise_for_error(self):
        self.rewind()
        self.advance(1)  # field_count == error (we already know that)
        errno = self.read_uint16()
        if DEBUG:
            print("errno =", errno)
>       err.raise_mysql_exception(self._data)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/protocol.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = b"\xff&\x04#23000Duplicate entry 'testteacher@gmail.com' for key 'user.email'"

    def raise_mysql_exception(data):
        errno = struct.unpack("<h", data[1:3])[0]
        errval = data[9:].decode("utf-8", "replace")
        errorclass = error_map.get(errno)
        if errorclass is None:
            errorclass = InternalError if errno < 1000 else OperationalError
>       raise errorclass(errno, errval)
E       sqlalchemy.exc.IntegrityError: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
E       [SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
E       [parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$1ihZrgqL4mGmhwON$3d12001aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 52, 77656)}]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/site-packages/pymysql/err.py:143: IntegrityError

During handling of the above exception, another exception occurred:

flask_app_mock = <Flask 'core'>

    def test_student_not_enrolled_in_this_course(flask_app_mock):
        with flask_app_mock.app_context():
            try:
                result = create_one_admin_ta_student_course(True, False, True)
                try:
                    message = teamImport.team_csv_to_db(
                        retrieve_file_path(
                            "oneTeamTAStudent.csv"
                        ),
                        result["admin_id"],
                        result["course_id"]
                    )
    
                except Exception as e:
                    assert isinstance(e, StudentNotEnrolledInThisCourse)
    
                teams = get_team_by_course_id(result["course_id"])
    
                error_message = "team_csv_to_db() should not assign a test team to a test course!"
                assert teams.__len__() == 0, error_message
    
                delete_one_admin_ta_student_course(result)
    
            except Exception as e:
>               delete_all_teams_team_members(result["course_id"])
E               UnboundLocalError: local variable 'result' referenced before assignment

Functions/test_files/test_teamImport.py:354: UnboundLocalError
----------------------------- Captured stderr call -----------------------------
2025-03-04 14:11:52,079 - ERROR - /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$1ihZrgqL4mGmhwON$3d12001aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 52, 77656)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
------------------------------ Captured log call -------------------------------
ERROR    rubricapp_logger:logger.py:126 /Users/sahammond/rubricapp/BackEndFlask/models/utility.py 114 Error Type: IntegrityError Message: (pymysql.err.IntegrityError) (1062, "Duplicate entry 'testteacher@gmail.com' for key 'user.email'")
[SQL: INSERT INTO `User` (first_name, last_name, email, password, lms_id, consent, owner_id, has_set_password, reset_code, is_admin, last_update) VALUES (%(first_name)s, %(last_name)s, %(email)s, %(password)s, %(lms_id)s, %(consent)s, %(owner_id)s, %(has_set_password)s, %(reset_code)s, %(is_admin)s, %(last_update)s)]
[parameters: {'first_name': 'Test Teacher', 'last_name': '1', 'email': 'testteacher@gmail.com', 'password': 'pbkdf2:sha256:260000$1ihZrgqL4mGmhwON$3d12001aa46fef3dcbd0d3744ac97eec8be89220607d39c068c756bf8f7aa142', 'lms_id': None, 'consent': None, 'owner_id': 1, 'has_set_password': 1, 'reset_code': None, 'is_admin': 0, 'last_update': datetime.datetime(2025, 3, 4, 14, 11, 52, 77656)}]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
=========================== short test summary info ============================
FAILED Functions/test_files/test_genericImport.py::test_should_fail_with_file_not_found
FAILED Functions/test_files/test_genericImport.py::test_should_fail_with_wrong_extension
FAILED Functions/test_files/test_genericImport.py::test_should_fail_with_not_enough_columns
FAILED Functions/test_files/test_genericImport.py::test_should_fail_with_misformatted_student_email
FAILED Functions/test_files/test_genericImport.py::test_valid_student_with_no_lms_id_in_table
FAILED Functions/test_files/test_genericImport.py::test_valid_student_with_lms_id_in_table
FAILED Functions/test_files/test_genericImport.py::test_valid_ta_with_no_lms_id_in_table
FAILED Functions/test_files/test_genericImport.py::test_valid_ta_with_lms_id_in_table
FAILED Functions/test_files/test_genericImport.py::test_valid_student_and_ta_with_no_lms_id_in_table
FAILED Functions/test_files/test_genericImport.py::test_valid_students_and_tas_with__and_without_lms_id_in_table
FAILED Functions/test_files/test_randAssignTeams.py::test_one_ta_ten_students
FAILED Functions/test_files/test_randAssignTeams.py::test_no_ta_ten_students
FAILED Functions/test_files/test_randAssignTeams.py::test_ten_tas_ten_students
FAILED Functions/test_files/test_randAssignTeams.py::test_TA_true_but_no_TAs_recorded_error
FAILED Functions/test_files/test_randAssignTeams.py::test_no_students_in_course_error
FAILED Functions/test_files/test_teamBulkUpload.py::test_should_fail_with_non_existant_ta_email
FAILED Functions/test_files/test_teamBulkUpload.py::test_should_fail_with_suspected_misformatting_error_given_misformatted_ta_email
FAILED Functions/test_files/test_teamBulkUpload.py::test_should_fail_with_empty_team_members
FAILED Functions/test_files/test_teamBulkUpload.py::test_should_fail_with_file_not_found_error_given_non_existent_file
FAILED Functions/test_files/test_teamBulkUpload.py::test_should_pass_when_given_one_team
FAILED Functions/test_files/test_teamBulkUpload.py::test_should_pass_when_given_two_teams_one_ta
FAILED Functions/test_files/test_teamBulkUpload.py::test_should_pass_when_given_three_teams_one_ta
FAILED Functions/test_files/test_teamBulkUpload.py::test_should_pass_when_given_2_teams_2_tas
FAILED Functions/test_files/test_teamImport.py::test_valid_file_w_tas_records_all_data
FAILED Functions/test_files/test_teamImport.py::test_valid_file_wo_tas_records_all_data
FAILED Functions/test_files/test_teamImport.py::test_wrong_file_type_error - ...
FAILED Functions/test_files/test_teamImport.py::test_file_not_found_error - U...
FAILED Functions/test_files/test_teamImport.py::test_misformatting_TA_email_error
FAILED Functions/test_files/test_teamImport.py::test_misformatting_student_email_error
FAILED Functions/test_files/test_teamImport.py::test_users_do_not_exist_error
FAILED Functions/test_files/test_teamImport.py::test_ta_not_yet_added_error
FAILED Functions/test_files/test_teamImport.py::test_student_not_enrolled_in_this_course
======================== 32 failed, 1 passed in 22.43s =========================
